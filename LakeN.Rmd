---
title: "LakeN"
author: "Yoav Ben Dor"
date: "6.12.2016"
output: html_document
---

```{r setup, include=FALSE , root.dir="F:/MyDocuments/GIT/LakeN"}
knitr::opts_chunk$set(echo = FALSE , warning=FALSE, message=FALSE)

setwd("F:/MyDocuments/GIT/LakeN/R")
source('depthinterp.R')
source('realdepth.R')
source('conctoquant.R')
source('daytoseason.R')

setwd("F:/MyDocuments/GIT/LakeN")

```

This model was written as a project for course 68806 Eco-hydrologic modelling with R
This model illustrates the annual N cycle in a lake in northern Israel, and simulates the transitions from oxydized species into reduced species

### read the data and load relevant libraries
```{r data read, echo=TRUE, warning=FALSE, message=FALSE}
# load relevant libraries
library(plyr)
library(zoo)
library(dplyr)
library(LakeN)
library(plot3D)
library(ggplot2)

# read the data for the model
# use the read.table function in the cas of a tab=delimited text file
# use the read.csv function for a csv

# data1 - measured gecochmical profiles
data1=read.table("LakeNData1.txt", header=TRUE)

# data2 - lake hypsometric curve including depth to area transformation
data2=read.table("LakeNData2.txt", header=TRUE)

# data3 - lake level measurments for depth corrections
data3=read.table("LakeNData3.txt", header=TRUE)

# data1 - temperature profile measurments
data4=read.table("LakeNData4.txt", header=TRUE)

# split the data set by measurment date
data1.split.orig=split(data1, f=data1$Date)

# fill NA cells with linear interpolation in original data
# initilize list to be filled
data1.split=vector("list", length(data1.split.orig))

first.data.col=3
dates=as.Date(unique(data1$Date, incomparables = FALSE))

for (ii in 1:length(data1.split.orig)){
  temp.df=data1.split.orig[[ii]]
  
  #find columns that are all NA and zero fill them prior to interpolation
  zero.index=NA
  zero.index=which(sapply(temp.df, function(x)all(is.na(x))))
  if (is.integer(zero.index)){
    temp.df[,zero.index]=c(rep.int(0, times=nrow(temp.df)))}
  
  # fill NA values confined between numbers using linear interoplation
  for (jj in first.data.col:ncol(temp.df)){
    app.var=as.double(na.approx(x=temp.df$Depth,as.numeric(unlist(temp.df[,jj])), method="linear",na.rm=FALSE))
    # remove NA values that are not confined between numbers with nearest value
    temp.df[,jj]=as.double(na.locf(na.locf(app.var,na.rm=FALSE),na.rm=FALSE, fromLast=TRUE))
  }
  
  #assign the interpolated values into the results list
  temp.name=as.character.Date(dates[ii])
  data1.split[[temp.name]]=data.frame(temp.df)
  rm(temp.df)
}

#remove any empty elemts of the list
data1.split[which(names(data1.split) %in% c(""))]=NULL

```

## Interpolate the Data into 1 m Intervals
Use the function "depthinterp"" to interpolate the data into uniform length for every 1 m
```{r interpolation, echo=TRUE, warning=FALSE, message=FALSE}

#define matrix size requiered for interpolating the data
n.col.interp=ncol(data1.split[[1]])
n.row.interp=40

#extract unique date values of measurments to be used for real level correction
dates=as.Date(unique(data1$Date, incomparables = FALSE))

# initialize an empty data frame for interpolation results
data1.split.interp=vector("list", length(data1.split))

# run interpolation function for each element
for (ii in 1:length(data1.split)){
  temp=depthinterp(input=na.locf(data1.split[[ii]]))
  temp.name=as.character.Date(dates[ii])
  data1.split.interp[[temp.name]]=data.frame(temp)
}
#remove any empty elemts of the list
data1.split.interp[which(names(data1.split.interp) %in% c(""))]=NULL
```


### Demonstrate interpolations of randomly selected data
```{r interpolation plots, echo=FALSE, warning=FALSE, message=FALSE}
# choose a random number to demonstrate the interpolation
rand.num=sample(1:length(data1.split),1)
rand.date=as.character.Date(dates[rand.num])

plot(data1.split[[rand.date]]$Oxygen,data1.split[[rand.date]]$Depth,  
     main=paste("Oxygen interpolation", rand.date),ylab="Depth [m]", xlab="Oxygen [mol/l]",
     ylim=rev(range(data1.split.interp[[rand.num]]$Depth)),
     xlim=c(0, as.double(max(data1.split[[rand.num]]$Oxygen))))
lines(data1.split.interp[[rand.date]]$Oxygen,data1.split.interp[[rand.date]]$Depth,  col=2)

#place a legend for an oxygen plot
legend(0, 1, c("Measured", "Interpolation"), col = c(1, 2),
       lty = c(NA,1), pch = c(1, NA),
       merge = TRUE, bg = "gray90")

plot(data1.split[[rand.date]]$Nitrate,data1.split[[rand.date]]$Depth,  
     main=paste("N species interpolation", rand.date),ylab="Depth [m]", xlab="Nitrate/NH4 [mol/l]",
     ylim=rev(range(data1.split.interp[[rand.date]]$Depth)), xlim=c(0,1.5*as.double(max(c(range(data1.split[[rand.date]]$Nitrate),range(data1.split[[rand.date]]$NH4))))), col=1)

lines(data1.split.interp[[rand.date]]$Nitrate,data1.split.interp[[rand.date]]$Depth,  col=2)
points(data1.split[[rand.date]]$NH4,data1.split[[rand.date]]$Depth, col=3)
lines(data1.split.interp[[rand.date]]$NH4,data1.split.interp[[rand.date]]$Depth,  col=4)

#place a legend for a geochemical plot
legend(1.05*as.double(max(c(max(data1.split[[rand.num]]$Nitrate),max(data1.split[[rand.num]]$NH4)))), 1, c("Measured NO2", "Interpolation","Measured NH4", "Interpolation"), col = c(1, 2,3,4),
       lty = c(NA,1,NA,1), pch = c(1,NA,1,NA),
       merge = TRUE, bg = "gray90")

```

## Depth and Level Corrections
calculate the appropriate depth for each measurment using available daily level measurments. Use function "realdepth" and use closest day if no level measurment of that day is available.
```{r level-depth correction, echo=TRUE, warning=FALSE, message=FALSE}
# this block arranges the depth of the measurments according to the lake level during that day

# initialize a data frame to accept the corrected data
data1.split.interp.depth=vector("list", length(data1.split.interp))
data1.split.depth=vector("list", length(data1.split.interp))

# run depth correction function for each element
for (ii in 1:length(dates)){
  temp.date=as.character.Date(dates[ii])
  temp=realdepth(depth.date=data3, measurment.date=temp.date, input=data1.split.interp[[temp.date]])
  data1.split.interp.depth[[temp.date]]=data.frame(temp)
  
  temp=realdepth(depth.date=data3, measurment.date=temp.date, input=data1.split[[temp.date]])
  data1.split.depth[[temp.date]]=data.frame(temp)
}
#remove any empty elemts of the list
data1.split.depth[which(names(data1.split.depth) %in% c(""))]=NULL
data1.split.interp.depth[which(names(data1.split.interp.depth) %in% c(""))]=NULL
```

### demonstrate the results according to the new depth scale of randomly selected data
```{r level-depth correction plots, echo=FALSE, warning=FALSE, message=FALSE}
# choose a random number to demonstrate the interpolation
rand.num=sample(1:length(data1.split),1)
rand.date=as.character.Date(dates[rand.num])

plot(data1.split.depth[[rand.date]]$Oxygen,data1.split.depth[[rand.date]]$Depth,  
     main=paste("Oxygen interpolation", rand.date),ylab="Depth [m]", xlab="Oxygen [mol/l]",
     ylim=range(data1.split.interp.depth[[rand.num]]$Depth), xlim=c(0, max(as.double(data1.split[[rand.date]]$Oxygen))))
lines(data1.split.interp.depth[[rand.date]]$Oxygen,data1.split.interp.depth[[rand.date]]$Depth,  col=2)

#place a legend for an oxygen plot
legend(0, as.double(max(data1.split.interp.depth[[rand.num]]$Depth)), c("Measured", "Interpolation"), col = c(1, 2),lty = c(NA,1), pch = c(1, NA), merge = TRUE, bg = "gray90")

plot(data1.split.depth[[rand.date]]$Nitrate,data1.split.depth[[rand.date]]$Depth,  
     main=paste("N species interpolation", rand.date),ylab="Depth [m]", xlab="Nitrate/NH4 [mol/l]",
     ylim=range(data1.split.interp.depth[[rand.date]]$Depth), xlim=c(0,1.5*max(c(max(as.double((data1.split[[rand.date]]$Nitrate))),max(as.double(data1.split[[rand.date]]$NH4))))), col=1)
lines(data1.split.interp.depth[[rand.date]]$Nitrate,data1.split.interp.depth[[rand.date]]$Depth,  col=2)
points(data1.split.depth[[rand.date]]$NH4,data1.split.depth[[rand.date]]$Depth, col=3)
lines(data1.split.interp.depth[[rand.date]]$NH4,data1.split.interp.depth[[rand.date]]$Depth,  col=4)

#place a legend for a geochemical plot
legend(1.05*max(c(max(as.double(data1.split[[rand.num]]$Nitrate)),max(as.double(data1.split[[rand.num]]$NH4)))), max(data1.split.interp.depth[[rand.num]]$Depth), c("Measured NO2", "Interpolation","Measured NH4", "Interpolation"), col = c(1, 2,3,4),lty = c(NA,1,NA,1), pch = c(1,NA,1,NA),merge = TRUE, bg = "gray90")

```

## Quantify the data using lake hypsometric curve

Quantify the amount of measured species using the hypsomentric curve of the lake using function "conctoquant". Multiply each depth value with its corresponding hypsometric value
```{r quntification, echo=TRUE, warning=FALSE, message=FALSE}
# this block calculates the total amount using the hypsometric curve of the lake

# initialize a data frame to accept the corrected data
data1.split.interp.depth.quant=vector("list", length(data1.split.interp.depth))
data1.split.depth.quant=vector("list", length(data1.split.depth))

# run quantification function for each element
for (ii in 1:length(dates)){
  temp.date=as.character.Date(dates[ii])
  temp=conctoquant(hypso.curve=data2, input=data1.split.interp.depth[[temp.date]])
  data1.split.interp.depth.quant[[temp.date]]=data.frame(temp)
  
  temp=conctoquant(hypso.curve=data2, input=data1.split.depth[[temp.date]])
  data1.split.depth.quant[[temp.date]]=data.frame(temp)
}
#remove any empty elemts of the list
data1.split.interp.depth.quant[which(names(data1.split.interp.depth.quant) %in% c(""))]=NULL
data1.split.depth.quant[which(names(data1.split.depth.quant) %in% c(""))]=NULL
```

### demonstrate the results according to the new depth scale of randomly selected data
```{r quntification plots, echo=FALSE, warning=FALSE, message=FALSE}
# choose a random number to demonstrate the interpolation
rand.num=sample(1:length(data1.split),1)
rand.date=as.character.Date(dates[rand.num])

plot(data1.split.depth.quant[[rand.date]]$Oxygen,data1.split.depth.quant[[rand.date]]$Depth,  
     main=paste("Oxygen interpolation", rand.date),ylab="Depth [m]", xlab="Oxygen [quant]",
     ylim=range(data1.split.interp.depth[[rand.num]]$Depth), xlim=c(0, max(as.double(data1.split.depth.quant[[rand.date]]$Oxygen))))
lines(data1.split.interp.depth.quant[[rand.date]]$Oxygen,data1.split.interp.depth.quant[[rand.date]]$Depth,  col=2)

#place a legend for an oxygen plot
legend(0, max(as.double(data1.split.interp.depth.quant[[rand.num]]$Depth)), c("Measured", "Interpolation"), col = c(1, 2),lty = c(NA,1), pch = c(1, NA), merge = TRUE, bg = "gray90")

plot(data1.split.depth.quant[[rand.date]]$Nitrate,data1.split.depth.quant[[rand.date]]$Depth,  
     main=paste("N species interpolation", rand.date),ylab="Depth [m]", xlab="Nitrate/NH4 [quant]",
     ylim=range(data1.split.interp.depth[[rand.date]]$Depth), xlim=c(0,1.5*max(c(max(as.double(data1.split.depth.quant[[rand.date]]$Nitrate),max(as.double(data1.split.depth.quant[[rand.date]]$NH4)))))), col=1)

lines(data1.split.interp.depth.quant[[rand.date]]$Nitrate,data1.split.interp.depth.quant[[rand.date]]$Depth,  col=2)

points(data1.split.depth.quant[[rand.date]]$NH4,data1.split.depth.quant[[rand.date]]$Depth, col=3)

lines(data1.split.interp.depth.quant[[rand.date]]$NH4,data1.split.interp.depth.quant[[rand.date]]$Depth,  col=4)

#place a legend for a geochemical plot
legend(1.05*max(c((data1.split.depth.quant[[rand.num]]$Nitrate),max(data1.split.depth.quant[[rand.num]]$NH4))), -215, c("Measured NO2", "Interpolation","Measured NH4", "Interpolation"), col = c(1, 2,3,4),lty = c(NA,1,NA,1), pch = c(1,NA,1,NA),merge = TRUE, bg = "gray90")

```


```{r data frame creation, echo=FALSE, warning=FALSE, message=FALSE}
# this block 

# create a dataframe based on interpolated data in list
# load the first element of the list
temp.2=as.data.frame(data1.split.interp.depth.quant[[1]])

# load all other elements in a loop
for (ii in 2:length(data1.split.interp.depth.quant)){
  temp=as.data.frame(data1.split.interp.depth.quant[[ii]])
  temp.2=rbind(temp.2,temp)
}
data1.split.interp.depth.quant.df=temp.2

#create a data frame where depth values are 1 to 40
data1.split.interp.quant.df=data1.split.interp.depth.quant.df
data1.split.interp.quant.df[["Depth"]]=rep(seq(from=1, to=40, by=1),length(data1.split.interp.quant.df[["Depth"]])/40)

# calculate matching season for every measurment day
day.season=data.frame(matrix(data=NA, ncol=2, nrow=length(data1.split.interp.quant.df)))
day.season=daytoseason(input=data1.split.interp.quant.df$Date)

data1.split.interp.quant.df=cbind(data1.split.interp.quant.df,day.season[,2:3])
data1.split.interp.depth.quant.df=cbind(data1.split.interp.depth.quant.df,day.season[,2:3])
```

## Time series plots

the following plots provide some visual estimation of the data to visualize time-depth processes
```{r time series visualization, echo=FALSE, warning=FALSE, message=FALSE}

# create x (date) and y (depth) vectors for plots
x= as.numeric(data1.split.interp.depth.quant.df$Date)
dim(x)=c(40,length(x)/40)
y= rep(seq(from=1, to=40, by=1), length(x)/40)
dim(y)=c(40,length(y)/40)

# uncomment these lines for absolute depth y axis
# remember to remove rev command from image2d

# y= as.numeric(data1.split.interp.depth.quant.df$Depth)
# dim(y)=c(40,length(y)/40)

# plot Oxygen values
z= data1.split.interp.depth.quant.df$Oxygen
dim(z)=c(40,length(z)/40)
image2D(z,x,y, main="Oxygen [amount]",xlab='',ylab="depth [m]",ylim=rev(range(y)),xaxt="n")
r <- as.POSIXct(range(data1.split.interp.depth.quant.df$Date), "weeks")
axis.Date(1, at = seq(r[1], r[2], by = "month"), format = "%m-%Y")

# plot Nitrate values
z= data1.split.interp.depth.quant.df$Nitrate
dim(z)=c(40,length(z)/40)
image2D(z,x,y, main="Nitrate [amount]",xlab='',ylab="depth [m]",ylim=rev(range(y)),xaxt="n")
r <- as.POSIXct(range(data1.split.interp.depth.quant.df$Date), "weeks")
axis.Date(1, at = seq(r[1], r[2], by = "month"), format = "%m-%Y")

# plot NH4 values
z= data1.split.interp.depth.quant.df$NH4
dim(z)=c(40,length(z)/40)
image2D(z,x,y, main="NH4 [amount]",xlab='',ylab="depth [m]",ylim=rev(range(y)),xaxt="n")
r <- as.POSIXct(range(data1.split.interp.depth.quant.df$Date), "weeks")
axis.Date(1, at = seq(r[1], r[2], by = "month"), format = "%m-%Y")

# plot Norparticular values
z= data1.split.interp.depth.quant.df$Norg_par
dim(z)=c(40,length(z)/40)
image2D(z,x,y, main="N Organic particular [amount]",xlab='',ylab="depth [m]",ylim=rev(range(y)),xaxt="n")
r <- as.POSIXct(range(data1.split.interp.depth.quant.df$Date), "weeks")
axis.Date(1, at = seq(r[1], r[2], by = "month"), format = "%m-%Y")

# plot Ntot values
z= data1.split.interp.depth.quant.df$Ntot
dim(z)=c(40,length(z)/40)
image2D(z,x,y, main="Total N [amount]",xlab='',ylab="depth [m]",ylim=rev(range(y)),xaxt="n")
r <- as.POSIXct(range(data1.split.interp.depth.quant.df$Date), "weeks")
axis.Date(1, at = seq(r[1], r[2], by = "month"), format = "%m-%Y")


```
## Time-depth cross sections

the following plots provide some visual estimation of the data to visualize time-depth processes
```{r time-depth sections, echo=FALSE, warning=FALSE, message=FALSE}

# plot a section through the data
x.depth=seq(from=5, to=40, by=5)

#initilize Oxygen plot
depth.indices=which(match(data1.split.interp.quant.df$Depth,x.depth[1])==1)
pox=ggplot(data=data1.split.interp.quant.df[depth.indices,], aes(x=Date, y=Oxygen, colour=Depth))+geom_line()
pox=pox+labs(title="Oxygen" ,x = "Month", y = "Oxygen[quant]")
pox=pox+scale_x_date(date_labels="%m-%Y", date_breaks="6 months")
pox=pox+scale_colour_gradient2(low = "red", mid = "green" , high = "blue", midpoint = 20)

for (ii in 2:length(x.depth)){
  depth.indices=which(match(data1.split.interp.quant.df$Depth,x.depth[ii])==1)
pox=pox+geom_line(data=data1.split.interp.quant.df[depth.indices,], aes(x=Date, y=Oxygen, colour=Depth))
}
pox

#initilize Nitrate plot
depth.indices=which(match(data1.split.interp.quant.df$Depth,x.depth[1])==1)
pnit=ggplot(data=data1.split.interp.quant.df[depth.indices,], aes(x=Date, y=Nitrate, colour=Depth))+geom_line()
pnit=pnit+labs(title="Nitrate" ,x = "Month", y = "Nitrate[quant]")
pnit=pnit+scale_x_date(date_labels="%m-%Y", date_breaks="6 months")
pnit=pnit+scale_colour_gradient2(low = "red", mid = "green" , high = "blue", midpoint = 20)

for (ii in 2:length(x.depth)){
  depth.indices=which(match(data1.split.interp.quant.df$Depth,x.depth[ii])==1)
pnit=pnit+geom_line(data=data1.split.interp.quant.df[depth.indices,], aes(x=Date, y=Nitrate, colour=Depth))
}
pnit

#initilize NH4 plot
depth.indices=which(match(data1.split.interp.quant.df$Depth,x.depth[1])==1)
pnh4=ggplot(data=data1.split.interp.quant.df[depth.indices,], aes(x=Date, y=NH4, colour=Depth))+geom_line()
pnh4=pnh4+labs(title="NH4" ,x = "Month", y = "NH4[quant]")
pnh4=pnh4+scale_x_date(date_labels="%m-%Y", date_breaks="6 months")
pnh4=pnh4+scale_colour_gradient2(low = "red", mid = "green" , high = "blue", midpoint = 20)
for (ii in 2:length(x.depth)){
  depth.indices=which(match(data1.split.interp.quant.df$Depth,x.depth[ii])==1)
pnh4=pnh4+geom_line(data=data1.split.interp.quant.df[depth.indices,], aes(x=Date, y=NH4, colour=Depth))
}
pnh4

```

## Correlation plots

the following plots provide some visual estimation of the data correlation
```{r correlation plots, echo=FALSE, warning=FALSE, message=FALSE}

d=ggplot(data=data1.split.interp.quant.df, aes(x=Oxygen, y=Nitrate, colour=Depth, shape=Season))+geom_point()
d=d+scale_colour_gradient2(low = "red", mid = "green" , high = "blue", midpoint = 20)
d


d=ggplot(data=data1.split.interp.quant.df, aes(x=NH4, y=Nitrate, colour=Season_ind, shape=Season))+geom_point()
d=d+scale_colour_gradient2(low = "red", mid = "green" , high = "blue", midpoint = 2)
d

d=ggplot(data=data1.split.interp.quant.df, aes(x=NH4, y=Nitrate, colour=Depth, shape=Season))+geom_point()
d=d+scale_colour_gradient2(low = "red", mid = "green" , high = "blue", midpoint = 20)
d

```

# Model fitting estimation
nitrification and denitrification are modelled for the stratified lake conditions, and are mixed during winter. depth 10 m is used to estimate nitrification processes, and depth 30 m is used to estimate denitrification
```{r parameter estimation, echo=FALSE, warning=FALSE, message=FALSE}
x.depth=c(10,30)
depth.for.model=vector(mode = "list", length=length(x.depth))

for (ii in 1:length(x.depth)){
  depth.indices=which(match(data1.split.interp.quant.df$Depth,x.depth[ii])==1)
  depth.for.model[[x.depth[ii]]]=data1.split.interp.quant.df[depth.indices,]
}
# remove empty elements from list
depth.for.model[which(names(depth.for.model) %in% c(""))]=NULL

d=ggplot(data=as.data.frame(depth.for.model[[10]]), aes(x=Date, y=Nitrate, colour=Oxygen, shape=Season))+geom_point()
d=d+scale_colour_gradient2(low = "blue",mid = "green" , high = "red", midpoint=(max(depth.for.model[[10]]$Oxygen)-min(depth.for.model[[10]]$Oxygen))/2)
d=d+labs(title="Nitrate depth 10[m]" ,x = "Month", y = "Nitrate[quant]")+scale_x_date(date_labels="%m-%Y", date_breaks="6 months")
d

d=ggplot(data=as.data.frame(depth.for.model[[10]]), aes(x=Date, y=NH4, colour=Oxygen, shape=Season))+geom_point()
d=d+scale_colour_gradient2(low = "blue", mid = "green" , high = "red", midpoint=(max(depth.for.model[[10]]$Oxygen)-min(depth.for.model[[10]]$Oxygen))/2)
d=d+labs(title="NH4 depth 10[m]" ,x = "Month", y = "NH4[quant]")+scale_x_date(date_labels="%m-%Y", date_breaks="6 months")
d

d=ggplot(data=as.data.frame(depth.for.model[[30]]), aes(x=Date, y=Nitrate, colour=Oxygen, shape=Season))+geom_point()
d=d+scale_colour_gradient2(low = "blue", mid = "green" , high = "red", midpoint=(max(depth.for.model[[30]]$Oxygen)-min(depth.for.model[[30]]$Oxygen))/2)
d=d+labs(title="Nitrate depth 30[m]" ,x = "Month", y = "Nitrate[quant]")+scale_x_date(date_labels="%m-%Y", date_breaks="6 months")
d

d=ggplot(data=as.data.frame(depth.for.model[[30]]), aes(x=Date, y=NH4, colour=Oxygen, shape=Season))+geom_point()
d=d+scale_colour_gradient2(low = "blue", mid = "green" , high = "red", midpoint=(max(depth.for.model[[30]]$Oxygen)-min(depth.for.model[[30]]$Oxygen))/2)
d=d+labs(title="NH4 depth 30[m]" ,x = "Month", y = "NH4[quant]")+scale_x_date(date_labels="%m-%Y", date_breaks="6 months")
d
```
