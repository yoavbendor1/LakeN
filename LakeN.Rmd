---
title: "LakeN"
author: "Yoav Ben Dor"
date: "6.12.2016"
output:
pdf_document: default
html_document: default
---

```{r setup, echo=FALSE ,include=FALSE , root.dir="F:/MyDocuments/GIT/LakeN"}
knitr::opts_chunk$set(echo = FALSE , warning=FALSE, message=FALSE)

# at home
setwd("F:/MyDocuments/GIT/LakeN/R")

# at HUJI
#setwd("C:/Users/user/Documents/LakeN/R")

source('depthinterp.R')
source('realdepth.R')
source('conctoquant.R')
source('daytoseason.R')
source('datesegmenter.R')
source('datedifference.R')
source('yearsegmenter.R')
source('yearassigner.R')
source('fitequation.R')
source('datesplitter.R')
source('yearbyelement.R')

# at home
 setwd("F:/MyDocuments/GIT/LakeN")
# at HUJI
#setwd("C:/Users/user/Documents/LakeN")

```

This model was written as a project for course 68806 Eco-hydrologic modelling with R
This model illustrates the annual N cycle in a lake in northern Israel, and simulates the transitions from oxydized species into reduced species

# Data preparation

### read the data and load relevant libraries
```{r data read, echo=FALSE, warning=FALSE, message=FALSE}
# load relevant libraries
library(plyr)
library(zoo)
library(dplyr)
library(LakeN)
library(plot3D)
library(ggplot2)

# read the data for the model
# use the read.table function in the cas of a tab=delimited text file
# use the read.csv function for a csv

# data1 - measured gecochmical profiles
data1=read.table("LakeNData1.txt", header=TRUE)

# data2 - lake hypsometric curve including depth to area transformation
data2=read.table("LakeNData2.txt", header=TRUE)

# data3 - lake level measurments for depth corrections
data3=read.table("LakeNData3.txt", header=TRUE)

# data1 - temperature profile measurments
data4=read.table("LakeNData4.txt", header=TRUE)

# split the data set by measurment date
data1.split.orig=split(data1, f=data1$Date)

# fill NA cells with linear interpolation in original data
# initilize list to be filled
data1.split=vector("list", length(data1.split.orig))

first.data.col=3
dates=as.Date(unique(data1$Date, incomparables = FALSE))

for (ii in 1:length(data1.split.orig)){
  temp.df=data1.split.orig[[ii]]
  
  #find columns that are all NA and zero fill them prior to interpolation
  zero.index=NA
  zero.index=which(sapply(temp.df, function(x)all(is.na(x))))
  if (is.integer(zero.index)){
    temp.df[,zero.index]=c(rep.int(0, times=nrow(temp.df)))}
  
  # fill NA values confined between numbers using linear interoplation
  for (jj in first.data.col:ncol(temp.df)){
    app.var=as.double(na.approx(x=temp.df$Depth,as.numeric(unlist(temp.df[,jj])), method="linear",na.rm=FALSE))
    # remove NA values that are not confined between numbers with nearest value
    temp.df[,jj]=as.double(na.locf(na.locf(app.var,na.rm=FALSE),na.rm=FALSE, fromLast=TRUE))
  }
  
  #assign the interpolated values into the results list
  temp.name=as.character.Date(dates[ii])
  data1.split[[temp.name]]=data.frame(temp.df)
  rm(temp.df)
}

#remove any empty elemts of the list
data1.split[which(names(data1.split) %in% c(""))]=NULL

```

## Interpolate the Data into 1 m Intervals
Use the function "depthinterp"" to interpolate the data into uniform length for every 1 m
```{r interpolation, echo=FALSE, warning=FALSE, message=FALSE}

#define matrix size requiered for interpolating the data
n.col.interp=ncol(data1.split[[1]])
n.row.interp=40

#extract unique date values of measurments to be used for real level correction
dates=as.Date(unique(data1$Date, incomparables = FALSE))

# initialize an empty data frame for interpolation results
data1.split.interp=vector("list", length=0)

# run interpolation function for each element
for (ii in 1:length(data1.split)){
  temp=depthinterp(input=na.locf(data1.split[[ii]]))
  temp.name=as.character.Date(dates[ii])
  data1.split.interp[[temp.name]]=data.frame(temp)
}
#remove any empty elemts of the list
data1.split.interp[which(names(data1.split.interp) %in% c(""))]=NULL
```


### Demonstrate interpolations of randomly selected data
```{r interpolation plots, echo=FALSE, warning=FALSE, message=FALSE}
# choose a random number to demonstrate the interpolation
rand.num=sample(1:length(data1.split),1)
rand.date=as.character.Date(dates[rand.num])

plot(data1.split[[rand.date]]$Oxygen,data1.split[[rand.date]]$Depth,  
     main=paste("Oxygen interpolation", rand.date),ylab="Depth [m]", xlab="Oxygen [mol/l]",
     ylim=rev(range(data1.split.interp[[rand.num]]$Depth)),
     xlim=c(0, as.double(max(data1.split[[rand.num]]$Oxygen))))
lines(data1.split.interp[[rand.date]]$Oxygen,data1.split.interp[[rand.date]]$Depth,  col=2)

#place a legend for an oxygen plot
legend(0, 1, c("Measured", "Interpolation"), col = c(1, 2),
       lty = c(NA,1), pch = c(1, NA),
       merge = TRUE, bg = "gray90")

plot(data1.split[[rand.date]]$Nitrate,data1.split[[rand.date]]$Depth,  
     main=paste("N species interpolation", rand.date),ylab="Depth [m]", xlab="Nitrate/NH4 [mol/l]",
     ylim=rev(range(data1.split.interp[[rand.date]]$Depth)), xlim=c(0,1.5*as.double(max(c(range(data1.split[[rand.date]]$Nitrate),range(data1.split[[rand.date]]$NH4))))), col=1)

lines(data1.split.interp[[rand.date]]$Nitrate,data1.split.interp[[rand.date]]$Depth,  col=2)
points(data1.split[[rand.date]]$NH4,data1.split[[rand.date]]$Depth, col=3)
lines(data1.split.interp[[rand.date]]$NH4,data1.split.interp[[rand.date]]$Depth,  col=4)

#place a legend for a geochemical plot
legend(1.05*as.double(max(c(max(data1.split[[rand.num]]$Nitrate),max(data1.split[[rand.num]]$NH4)))), 1, c("Measured NO2", "Interpolation","Measured NH4", "Interpolation"), col = c(1, 2,3,4),
       lty = c(NA,1,NA,1), pch = c(1,NA,1,NA),
       merge = TRUE, bg = "gray90")

```

## Depth and Level Corrections
calculate the appropriate depth for each measurment using available daily level measurments. Use function "realdepth" and use closest day if no level measurment of that day is available.
```{r level-depth correction, echo=FALSE, warning=FALSE, message=FALSE}
# this block arranges the depth of the measurments according to the lake level during that day

# initialize a data frame to accept the corrected data
data1.split.interp.depth=vector("list", length=0)
data1.split.depth=vector("list", length=0)

# run depth correction function for each element
for (ii in 1:length(dates)){
  temp.date=as.character.Date(dates[ii])
  temp=realdepth(depth.date=data3, measurment.date=temp.date, input=data1.split.interp[[temp.date]])
  data1.split.interp.depth[[temp.date]]=data.frame(temp)
  
  temp=realdepth(depth.date=data3, measurment.date=temp.date, input=data1.split[[temp.date]])
  data1.split.depth[[temp.date]]=data.frame(temp)
}
#remove any empty elemets of the list
data1.split.depth[which(names(data1.split.depth) %in% c(""))]=NULL
data1.split.interp.depth[which(names(data1.split.interp.depth) %in% c(""))]=NULL
```

### demonstrate the results according to the new depth scale of randomly selected data
```{r level-depth correction plots, echo=FALSE, warning=FALSE, message=FALSE}
# choose a random number to demonstrate the interpolation
rand.num=sample(1:length(data1.split),1)
rand.date=as.character.Date(dates[rand.num])

plot(data1.split.depth[[rand.date]]$Oxygen,data1.split.depth[[rand.date]]$Depth,  
     main=paste("Oxygen interpolation", rand.date),ylab="Depth [m]", xlab="Oxygen [mol/l]",
     ylim=range(data1.split.interp.depth[[rand.num]]$Depth), xlim=c(0, max(as.double(data1.split[[rand.date]]$Oxygen))))
lines(data1.split.interp.depth[[rand.date]]$Oxygen,data1.split.interp.depth[[rand.date]]$Depth,  col=2)

#place a legend for an oxygen plot
legend(0, as.double(max(data1.split.interp.depth[[rand.num]]$Depth)), c("Measured", "Interpolation"), col = c(1, 2),lty = c(NA,1), pch = c(1, NA), merge = TRUE, bg = "gray90")

plot(data1.split.depth[[rand.date]]$Nitrate,data1.split.depth[[rand.date]]$Depth,  
     main=paste("N species interpolation", rand.date),ylab="Depth [m]", xlab="Nitrate/NH4 [mol/l]",
     ylim=range(data1.split.interp.depth[[rand.date]]$Depth), xlim=c(0,1.5*max(c(max(as.double((data1.split[[rand.date]]$Nitrate))),max(as.double(data1.split[[rand.date]]$NH4))))), col=1)
lines(data1.split.interp.depth[[rand.date]]$Nitrate,data1.split.interp.depth[[rand.date]]$Depth,  col=2)
points(data1.split.depth[[rand.date]]$NH4,data1.split.depth[[rand.date]]$Depth, col=3)
lines(data1.split.interp.depth[[rand.date]]$NH4,data1.split.interp.depth[[rand.date]]$Depth,  col=4)

#place a legend for a geochemical plot
legend(1.05*max(c(max(as.double(data1.split[[rand.num]]$Nitrate)),max(as.double(data1.split[[rand.num]]$NH4)))), max(data1.split.interp.depth[[rand.num]]$Depth), c("Measured NO2", "Interpolation","Measured NH4", "Interpolation"), col = c(1, 2,3,4),lty = c(NA,1,NA,1), pch = c(1,NA,1,NA),merge = TRUE, bg = "gray90")

```

## Quantify the data using lake hypsometric curve

Quantify the amount of measured species using the hypsomentric curve of the lake using function "conctoquant". Multiply each depth value with its corresponding hypsometric value
```{r quntification, echo=FALSE, warning=FALSE, message=FALSE}
# this block calculates the total amount using the hypsometric curve of the lake

# initialize a data frame to accept the corrected data
data1.split.interp.depth.quant=vector("list", length=0)
data1.split.depth.quant=vector("list", length=0)

# run quantification function for each element
for (ii in 1:length(dates)){
  temp.date=as.character.Date(dates[ii])
  temp=conctoquant(hypso.curve=data2, input=data1.split.interp.depth[[temp.date]])
  data1.split.interp.depth.quant[[temp.date]]=data.frame(temp)
  
  temp=conctoquant(hypso.curve=data2, input=data1.split.depth[[temp.date]])
  data1.split.depth.quant[[temp.date]]=data.frame(temp)

}
#remove any empty elemts of the list
data1.split.interp.depth.quant[which(names(data1.split.interp.depth.quant) %in% c(""))]=NULL
data1.split.depth.quant[which(names(data1.split.depth.quant) %in% c(""))]=NULL
```

### demonstrate the results according to the new depth scale of randomly selected data
```{r quntification plots, echo=FALSE, warning=FALSE, message=FALSE}
# choose a random number to demonstrate the interpolation
rand.num=sample(1:length(data1.split),1)
rand.date=as.character.Date(dates[rand.num])

plot(data1.split.depth.quant[[rand.date]]$Oxygen,data1.split.depth.quant[[rand.date]]$Depth,  
     main=paste("Oxygen interpolation", rand.date),ylab="Depth [m]", xlab="Oxygen [quant]",
     ylim=range(data1.split.interp.depth[[rand.num]]$Depth), xlim=c(0, max(as.double(data1.split.depth.quant[[rand.date]]$Oxygen))))
lines(data1.split.interp.depth.quant[[rand.date]]$Oxygen,data1.split.interp.depth.quant[[rand.date]]$Depth,  col=2)

#place a legend for an oxygen plot
legend(0, max(as.double(data1.split.interp.depth.quant[[rand.num]]$Depth)), c("Measured", "Interpolation"), col = c(1, 2),lty = c(NA,1), pch = c(1, NA), merge = TRUE, bg = "gray90")

plot(data1.split.depth.quant[[rand.date]]$Nitrate,data1.split.depth.quant[[rand.date]]$Depth,  
     main=paste("N species interpolation", rand.date),ylab="Depth [m]", xlab="Nitrate/NH4 [quant]",
     ylim=range(data1.split.interp.depth[[rand.date]]$Depth), xlim=c(0,1.5*max(c(max(as.double(data1.split.depth.quant[[rand.date]]$Nitrate),max(as.double(data1.split.depth.quant[[rand.date]]$NH4)))))), col=1)

lines(data1.split.interp.depth.quant[[rand.date]]$Nitrate,data1.split.interp.depth.quant[[rand.date]]$Depth,  col=2)

points(data1.split.depth.quant[[rand.date]]$NH4,data1.split.depth.quant[[rand.date]]$Depth, col=3)

lines(data1.split.interp.depth.quant[[rand.date]]$NH4,data1.split.interp.depth.quant[[rand.date]]$Depth,  col=4)

#place a legend for a geochemical plot
legend(1.05*max(c((data1.split.depth.quant[[rand.num]]$Nitrate),max(data1.split.depth.quant[[rand.num]]$NH4))), -215, c("Measured NO2", "Interpolation","Measured NH4", "Interpolation"), col = c(1, 2,3,4),lty = c(NA,1,NA,1), pch = c(1,NA,1,NA),merge = TRUE, bg = "gray90")

```


```{r data frame creation, echo=FALSE, warning=FALSE, message=FALSE}
# create a dataframe based on interpolated data in list
# load the first element of the list
data1.split.interp.depth.quant.df=as.data.frame(data1.split.interp.depth.quant[[1]])
oxygen.concentration.interp=as.data.frame(data1.split.interp.depth[[1]]$Oxygen)
colnames(oxygen.concentration.interp)=c("Oxygen")

# load all other elements in a loop
for (ii in 2:length(data1.split.interp.depth.quant)){
  temp=as.data.frame(data1.split.interp.depth.quant[[ii]])
  temp.ox=as.data.frame(data1.split.interp.depth[[ii]]$Oxygen)
  colnames(temp.ox)=c("Oxygen")
  
  data1.split.interp.depth.quant.df=rbind(data1.split.interp.depth.quant.df,temp)
  oxygen.concentration.interp=rbind(oxygen.concentration.interp,temp.ox)
}
colnames(oxygen.concentration.interp)=c("Oxygen_conc")

data1.split.interp.depth.quant.df=cbind(data1.split.interp.depth.quant.df,oxygen.concentration.interp)

#create a data frame where depth values are 1 to 40
data1.split.interp.quant.df=data1.split.interp.depth.quant.df
data1.split.interp.quant.df[["Depth"]]=rep(seq(from=1, to=40, by=1),length(data1.split.interp.quant.df[["Depth"]])/40)
data1.split.interp.quant.df=cbind(data1.split.interp.quant.df,oxygen.concentration.interp)

# calculate matching season for every measurment day
day.season=data.frame(matrix(data=NA, ncol=2, nrow=length(data1.split.interp.quant.df)))
day.season=daytoseason(input=data1.split.interp.quant.df$Date)

data1.split.interp.quant.df=cbind(data1.split.interp.quant.df,day.season[,2:3])
data1.split.interp.depth.quant.df=cbind(data1.split.interp.depth.quant.df,day.season[,2:3])
```

## Time series plots

the following plots provide some visual estimation of the data to visualize time-depth processes
```{r time series visualization, echo=FALSE, warning=FALSE, message=FALSE}

# create x (date) and y (depth) vectors for plots
x= as.numeric(data1.split.interp.depth.quant.df$Date)
dim(x)=c(40,length(x)/40)
y= rep(seq(from=1, to=40, by=1), length(x)/40)
dim(y)=c(40,length(y)/40)

# uncomment these lines for absolute depth y axis
# remember to remove rev command from image2d

# y= as.numeric(data1.split.interp.depth.quant.df$Depth)
# dim(y)=c(40,length(y)/40)

# plot Oxygen values
z= data1.split.interp.depth.quant.df$Oxygen
dim(z)=c(40,length(z)/40)
image2D(z,x,y, main="Oxygen [amount]",xlab='',ylab="depth [m]",ylim=rev(range(y)),xaxt="n")
r <- as.POSIXct(range(data1.split.interp.depth.quant.df$Date), "weeks")
axis.Date(1, at = seq(r[1], r[2], by = "month"), format = "%m-%Y")

# plot Oxygen concentration values
z=oxygen.concentration.interp
z=matrix(as.matrix(oxygen.concentration.interp), nrow=40, ncol=nrow(z)/40)
image2D(z,x,y, main="Oxygen [concentration]",xlab='',ylab="depth [m]",ylim=rev(range(y)),xaxt="n")
r <- as.POSIXct(range(data1.split.interp.depth.quant.df$Date), "weeks")
axis.Date(1, at = seq(r[1], r[2], by = "month"), format = "%m-%Y")

# plot Nitrate values
z= data1.split.interp.depth.quant.df$Nitrate
dim(z)=c(40,length(z)/40)
image2D(z,x,y, main="Nitrate [amount]",xlab='',ylab="depth [m]",ylim=rev(range(y)),xaxt="n")
r <- as.POSIXct(range(data1.split.interp.depth.quant.df$Date), "weeks")
axis.Date(1, at = seq(r[1], r[2], by = "month"), format = "%m-%Y")

# plot NH4 values
z= data1.split.interp.depth.quant.df$NH4
dim(z)=c(40,length(z)/40)
image2D(z,x,y, main="NH4 [amount]",xlab='',ylab="depth [m]",ylim=rev(range(y)),xaxt="n")
r <- as.POSIXct(range(data1.split.interp.depth.quant.df$Date), "weeks")
axis.Date(1, at = seq(r[1], r[2], by = "month"), format = "%m-%Y")

# plot Norparticular values
z= data1.split.interp.depth.quant.df$Norg_par
dim(z)=c(40,length(z)/40)
image2D(z,x,y, main="N Organic particular [amount]",xlab='',ylab="depth [m]",ylim=rev(range(y)),xaxt="n")
r <- as.POSIXct(range(data1.split.interp.depth.quant.df$Date), "weeks")
axis.Date(1, at = seq(r[1], r[2], by = "month"), format = "%m-%Y")

# plot Ntot values
z= data1.split.interp.depth.quant.df$Ntot
dim(z)=c(40,length(z)/40)
image2D(z,x,y, main="Total N [amount]",xlab='',ylab="depth [m]",ylim=rev(range(y)),xaxt="n")
r <- as.POSIXct(range(data1.split.interp.depth.quant.df$Date), "weeks")
axis.Date(1, at = seq(r[1], r[2], by = "month"), format = "%m-%Y")


```

## Time-depth cross sections

the following plots provide some visual estimation of the data to visualize time-depth processes
```{r time-depth sections, echo=FALSE, warning=FALSE, message=FALSE}

# plot a section through the data
x.depth=seq(from=5, to=40, by=5)

#initilize Oxygen plot
depth.indices=which(match(data1.split.interp.quant.df$Depth,x.depth[1])==1)
pox=ggplot(data=data1.split.interp.quant.df[depth.indices,], aes(x=Date, y=Oxygen, colour=Depth))+geom_line()
pox=pox+labs(title="Oxygen" ,x = "Month", y = "Oxygen[quant]")
pox=pox+scale_x_date(date_labels="%m-%Y", date_breaks="6 months")
pox=pox+scale_colour_gradient2(low = "red", mid = "green" , high = "blue", midpoint = 20)

for (ii in 2:length(x.depth)){
  depth.indices=which(match(data1.split.interp.quant.df$Depth,x.depth[ii])==1)
  pox=pox+geom_line(data=data1.split.interp.quant.df[depth.indices,], aes(x=Date, y=Oxygen, colour=Depth))
}
pox

#initilize Oxygen plot
depth.indices=which(match(data1.split.interp.quant.df$Depth,x.depth[1])==1)
pox=ggplot(data=data1.split.interp.quant.df[depth.indices,], aes(x=Date, y=Oxygen_conc, colour=Depth))+geom_line()
pox=pox+labs(title="Oxygen" ,x = "Month", y = "Oxygen[conc]")
pox=pox+scale_x_date(date_labels="%m-%Y", date_breaks="6 months")
pox=pox+scale_colour_gradient2(low = "red", mid = "green" , high = "blue", midpoint = 20)

for (ii in 2:length(x.depth)){
  depth.indices=which(match(data1.split.interp.quant.df$Depth,x.depth[ii])==1)
  pox=pox+geom_line(data=data1.split.interp.quant.df[depth.indices,], aes(x=Date, y=Oxygen_conc, colour=Depth))
}
pox


#initilize Nitrate plot
depth.indices=which(match(data1.split.interp.quant.df$Depth,x.depth[1])==1)
pnit=ggplot(data=data1.split.interp.quant.df[depth.indices,], aes(x=Date, y=Nitrate, colour=Depth))+geom_line()
pnit=pnit+labs(title="Nitrate" ,x = "Month", y = "Nitrate[quant]")
pnit=pnit+scale_x_date(date_labels="%m-%Y", date_breaks="6 months")
pnit=pnit+scale_colour_gradient2(low = "red", mid = "green" , high = "blue", midpoint = 20)

for (ii in 2:length(x.depth)){
  depth.indices=which(match(data1.split.interp.quant.df$Depth,x.depth[ii])==1)
  pnit=pnit+geom_line(data=data1.split.interp.quant.df[depth.indices,], aes(x=Date, y=Nitrate, colour=Depth))
}
pnit

#initilize NH4 plot
depth.indices=which(match(data1.split.interp.quant.df$Depth,x.depth[1])==1)
pnh4=ggplot(data=data1.split.interp.quant.df[depth.indices,], aes(x=Date, y=NH4, colour=Depth))+geom_line()
pnh4=pnh4+labs(title="NH4" ,x = "Month", y = "NH4[quant]")
pnh4=pnh4+scale_x_date(date_labels="%m-%Y", date_breaks="6 months")
pnh4=pnh4+scale_colour_gradient2(low = "red", mid = "green" , high = "blue", midpoint = 20)
for (ii in 2:length(x.depth)){
  depth.indices=which(match(data1.split.interp.quant.df$Depth,x.depth[ii])==1)
  pnh4=pnh4+geom_line(data=data1.split.interp.quant.df[depth.indices,], aes(x=Date, y=NH4, colour=Depth))
}
pnh4

```

## Correlation plots

the following plots provide some visual estimation of the data correlation

```{r correlation plots, echo=FALSE, warning=FALSE, message=FALSE}

d=ggplot(data=data1.split.interp.quant.df, aes(x=Oxygen, y=Nitrate, colour=Depth, shape=Season))+geom_point()
d=d+scale_colour_gradient2(low = "red", mid = "green" , high = "blue", midpoint = 20)
d=d+labs(title=paste("Nitrate vs. Oxygen"),x = "Oxygen [quant]", y = "Nitrate[quant]")
d

d=ggplot(data=data1.split.interp.quant.df, aes(x=Oxygen_conc, y=Nitrate, colour=Depth, shape=Season))+geom_point()
d=d+scale_colour_gradient2(low = "red", mid = "green" , high = "blue", midpoint = 20)
d=d+labs(title=paste("Nitrate vs. Oxygen"),x = "Oxygen [conc]", y = "Nitrate[quant]")
d

d=ggplot(data=data1.split.interp.quant.df, aes(x=Oxygen, y=NH4, colour=Depth, shape=Season))+geom_point()
d=d+scale_colour_gradient2(low = "red", mid = "green" , high = "blue", midpoint = 20)
d=d+labs(title=paste("NH4 vs. Oxygen"),x = "Oxygen [quant]", y = "NH4[quant]")
d

d=ggplot(data=data1.split.interp.quant.df, aes(x=Oxygen_conc, y=NH4, colour=Depth, shape=Season))+geom_point()
d=d+scale_colour_gradient2(low = "red", mid = "green" , high = "blue", midpoint = 20)
d=d+labs(title=paste("NH4 vs. Oxygen"),x = "Oxygen [conc]", y = "NH4[quant]")
d

d=ggplot(data=data1.split.interp.quant.df, aes(x=NH4, y=Nitrate, colour=Season_ind, shape=Season))+geom_point()
d=d+scale_colour_gradient2(low = "red", mid = "green" , high = "blue", midpoint = 2)
d=d+labs(title=paste("Nitrate vs. NH4"),x = "Oxygen [quant]", y = "NH4[quant]")
d

d=ggplot(data=data1.split.interp.quant.df, aes(x=NH4, y=Nitrate, colour=Depth, shape=Season))+geom_point()
d=d+scale_colour_gradient2(low = "red", mid = "green" , high = "blue", midpoint = 20)
d=d+labs(title=paste("Nitrate vs. NH4"),x = "Oxygen [quant]", y = "NH4[quant]")
d

```

# Model fitting estimation

nitrification and denitrification are modelled for the stratified lake conditions, and are mixed during winter. depth 10 m is used to estimate nitrification processes, and depth 30 m is used to estimate denitrification

```{r parameter estimation1, echo=FALSE, warning=FALSE, message=FALSE}
x.depth=c(10,30)
depth.for.model=vector(mode = "list", length=0)

for (ii in 1:length(x.depth)){
  depth.indices=which(match(data1.split.interp.quant.df$Depth,x.depth[ii])==1)
  depth.for.model[[x.depth[ii]]]=data1.split.interp.quant.df[depth.indices,]
}
# remove empty elements from list
depth.for.model[sapply(depth.for.model, is.null)] =NULL

for (ii in 1:length(x.depth)){
  depth.for.model[[x.depth[ii]]]=data1.split.interp.quant.df[depth.indices,]
}

d=ggplot(data=as.data.frame(depth.for.model[[1]]), aes(x=Date, y=Nitrate, colour=Oxygen, shape=Season))+geom_point()

d=d+scale_colour_gradient2(low = "blue",mid = "green" , high = "red", midpoint=(max(depth.for.model[[1]]$Oxygen)-min(depth.for.model[[1]]$Oxygen))/1)
d=d+labs(title=paste("Nitrate depth:", x.depth[1],"[m]"),x = "Month", y = "Nitrate[quant]")+scale_x_date(date_labels="%m-%Y", date_breaks="6 months")
d

d=ggplot(data=as.data.frame(depth.for.model[[1]]), aes(x=Date, y=NH4, colour=Oxygen, shape=Season))+geom_point()

d=d+scale_colour_gradient2(low = "blue", mid = "green" , high = "red", midpoint=(max(depth.for.model[[1]]$Oxygen)-min(depth.for.model[[1]]$Oxygen))/1)
d=d+labs(title=paste("NH4 depth:", x.depth[1],"[m]") ,x = "Month", y = "NH4[quant]")+scale_x_date(date_labels="%m-%Y", date_breaks="6 months")
d

d=ggplot(data=as.data.frame(depth.for.model[[2]]), aes(x=Date, y=Nitrate, colour=Oxygen, shape=Season))+geom_point()

d=d+scale_colour_gradient2(low = "blue", mid = "green" , high = "red", midpoint=(max(depth.for.model[[2]]$Oxygen)-min(depth.for.model[[2]]$Oxygen))/2)
d=d+labs(title=paste("Nitrate depth:", x.depth[2],"[m]") ,x = "Month", y = "Nitrate[quant]")+scale_x_date(date_labels="%m-%Y", date_breaks="6 months")
d

d=ggplot(data=as.data.frame(depth.for.model[[2]]), aes(x=Date, y=NH4, colour=Oxygen, shape=Season))+geom_point()

d=d+scale_colour_gradient2(low = "blue", mid = "green" , high = "red", midpoint=(max(depth.for.model[[2]]$Oxygen)-min(depth.for.model[[2]]$Oxygen))/2)
d=d+labs(title=paste("NH4 depth:", x.depth[2],"[m]") ,x = "Month", y = "NH4[quant]")+scale_x_date(date_labels="%m-%Y", date_breaks="6 months")
d
```

### simulate NH4 build-up between May and December in 30m depth in order to estimate reaction rate

```{r parameter estimation2, echo=FALSE, warning=FALSE, message=FALSE}
# segment the data to model by dates
# the dates will be segmented into a list containing the relevant dates for every year
temp.30=datesegmenter( min.date=as.Date("2010-04-30"),max.date=as.Date("2010-12-01"), input=as.data.frame(depth.for.model[[2]]), first.data.col=3)
# assign the year to each measurment
temp2.30=yearassigner(input=temp.30)
# split the data set into a year-based list
temp3.30=split(temp2.30,f=temp2.30$Year)
# find the time [in days] between measurments
datedif.30=datedifference(temp3.30)

# attach the data-difference vector to the list
data.for.model.30=vector("list", length=0)
names.30=names(temp3.30)

for (ii in 1:length(temp3.30)){
  data.for.model.30[[names.30[ii]]]=as.data.frame(cbind(temp3.30[[ii]],datedif.30[[2]][[ii]]))
  names(data.for.model.30[[ii]])[names(data.for.model.30[[ii]]) == 'V1'] = 'Date_seq'
}

# remove empty elements from list
data.for.model.30[sapply(data.for.model.30, is.null)] =NULL

## create a dataframe based on the list for the model
# load the first element of the list
data.for.model.30.df=as.data.frame(data.for.model.30[[1]])
temp.2=data.for.model.30[[1]]
# load all other elements in a loop
for (ii in 2:length(data.for.model.30)){
  temp=as.data.frame(data.for.model.30[[ii]])
  temp.2=rbind(temp.2,temp)
}
data.for.model.30.df=temp.2

lm1.30.NH4=lm(temp3.30$'2010'$NH4~unlist(datedif.30[[2]]$'2010'))
lm2.30.NH4=lm(temp3.30$'2011'$NH4~unlist(datedif.30[[2]]$'2011'))
lm3.30.NH4=lm(temp3.30$'2012'$NH4~unlist(datedif.30[[2]]$'2012'))
lm4.30.NH4=lm(temp3.30$'2013'$NH4~unlist(datedif.30[[2]]$'2013'))

eq.1=fitequation(lm1.30.NH4)
eq.2=fitequation(lm2.30.NH4)
eq.3=fitequation(lm3.30.NH4)
eq.4=fitequation(lm4.30.NH4)

d=ggplot(data=data.for.model.30.df, aes(x=Date_seq, y=NH4, colour=Year))+geom_point()
d=d+labs(title=paste("NH4 build-up depth:", x.depth[2],"[m]") ,x = "Days from measurment", y = "NH4[quant]")
d=d+geom_smooth(method='lm')
d=d+geom_text(x = 50, y = 6E+07, label = eq.1, parse = TRUE, colour="red")
d=d+geom_text(x = 50, y = 5.5E+07, label = eq.2, parse = TRUE, colour="dark green")
d=d+geom_text(x = 50, y = 5.0E+07, label = eq.3, parse = TRUE, colour="blue")
d=d+geom_text(x = 50, y = 4.5E+07, label = eq.4, parse = TRUE, colour="purple")
d

```

### simulate Nitrate build-up between November and May in 10m depth in order to estimate reaction rate

```{r parameter estimation3, echo=FALSE, warning=FALSE, message=FALSE}
# segment the data to model by dates
# the dates will be segmented into a list containing the relevant dates for every year
# if the time span ranges acrros Jan 1st, be sure to change the year in the ma.date value
temp.10=datesegmenter(min.date=as.Date("2010-11-01"), max.date=as.Date("2011-04-30"), input=as.data.frame(depth.for.model[[2]]), first.data.col=3)
# assign the year to each measurment
temp2.10=yearassigner(input=temp.10)
# split the data set into a "season-based" list
temp3.10=datesplitter(temp2.10,min.date="2010-11-01",max.date="2011-05-01")
# cahnge the year value by element name for following plotting with ggplot
temp3.10=yearbyelement(input=temp3.10)
# find the time [in days] between measurments
datedif.10=datedifference(temp3.10)

# attach the data-difference vector to the list
data.for.model.10=vector("list", length=0)
names.10=names(temp3.10)

for (ii in 1:length(temp3.10)){
  data.for.model.10[[names.10[ii]]]=as.data.frame(cbind(temp3.10[[ii]],datedif.10[[2]][[ii]]))
  names(data.for.model.10[[ii]])[names(data.for.model.10[[ii]]) == 'V1'] = 'Date_seq'
}

# remove empty elements from list
data.for.model.10[sapply(data.for.model.10, is.null)] =NULL

## create a dataframe based on the list for the model
# load the first element of the list
data.for.model.10.df=as.data.frame(data.for.model.10[[1]])
temp.2=data.for.model.10[[1]]
# load all other elements in a loop
for (ii in 2:length(data.for.model.10)){
  temp=as.data.frame(data.for.model.10[[ii]])
  temp.2=rbind(temp.2,temp)
}
data.for.model.10.df=temp.2

lm1.10.Nitrate=lm(temp3.10$'2011'$Nitrate~unlist(datedif.10[[2]]$'2011'))
lm2.10.Nitrate=lm(temp3.10$'2012'$Nitrate~unlist(datedif.10[[2]]$'2012'))
lm3.10.Nitrate=lm(temp3.10$'2013'$Nitrate~unlist(datedif.10[[2]]$'2013'))

eq.1=fitequation(lm1.10.Nitrate)
eq.2=fitequation(lm2.10.Nitrate)
eq.3=fitequation(lm3.10.Nitrate)

d=ggplot(data=data.for.model.10.df, aes(x=Date_seq, y=Nitrate, colour=Year))+geom_point()
d=d+labs(title=paste("Nitrate build-up depth:", x.depth[1],"[m]") ,x = "Days from measurment", y = "Nitrate[quant]")
d=d+geom_smooth(method='lm')
d=d+geom_text(x = 50, y = 4.5E+07, label = eq.1, parse = TRUE, colour="red")
d=d+geom_text(x = 50, y = 4.0E+07, label = eq.2, parse = TRUE, colour="dark green")
d=d+geom_text(x = 50, y = 3.5E+07, label = eq.3, parse = TRUE, colour="blue")
d

```

### coeffiecients assement for all depths

```{r parameter estimation4, echo=FALSE, warning=FALSE, message=FALSE}

x.depth=seq(from=1, to=40, by=1)
data.for.model=vector(mode = "list", length=0)

for (ii in 1:length(x.depth)){
  depth.indices=which(match(data1.split.interp.quant.df$Depth,x.depth[ii])==1)
  data.for.model[[x.depth[ii]]]=data1.split.interp.quant.df[depth.indices,]
}
# remove empty elements from list
data.for.model[sapply(data.for.model, is.null)] =NULL

#define min and max date for modelling
min.date=as.Date("2010-11-01")
max.date=as.Date("2011-04-30")

# initialize empty lists for model parameters collection
lm.Nitrate=vector("list", length=0)
model.param=vector("list", length=0)
Nitrate.model=vector("list", length=0)

for (ii in 1:length(x.depth)){
  temp=datesegmenter(min.date=min.date, max.date=max.date, input=as.data.frame(data.for.model[[x.depth[ii]]]), first.data.col=3)
  
  # assign the year to each measurment
  temp2=yearassigner(input=temp)
  
  # split the data set into a "season-based" list
  temp3=datesplitter(temp2,min.date=min.date,max.date=max.date)
  
  # cahnge the year value by element name for following plotting with ggplot
  temp3=yearbyelement(input=temp3)
  
  # find the time [in days] between measurments
  datedif=datedifference(temp3)
  
  # attach the data-difference vector to the list
  data.for.model.loop=vector("list", length=0)
  names=names(temp3)
  
  for (jj in 1:length(temp3)){
    data.for.model.loop[[names[jj]]]=as.data.frame(cbind(temp3[[jj]],datedif[[2]][[jj]]))
    names(data.for.model.loop[[jj]])[names(data.for.model.loop[[jj]]) == 'V1'] = 'Date_seq'
  }
  
  # remove empty elements from list
  data.for.model.loop[sapply(data.for.model.loop, is.null)] =NULL
  
  temp.names=names(temp3)
  for (jj in 1:length(temp.names)){
    lm.Nitrate[[temp.names[jj]]]=lm(temp3[[jj]]$Nitrate~unlist(datedif[[2]][[jj]]))
    
    a = format(coef(lm.Nitrate[[jj]])[1], digits = 2, scientific=TRUE)
    b = format(coef(lm.Nitrate[[jj]])[2], digits = 2, scientific=TRUE)
    r2 = format(summary(lm.Nitrate[[jj]])$r.squared, digits = 2)
    
    model.param[[temp.names[jj]]]=data.frame(ii,a,b,r2)
    rownames(model.param[[temp.names[jj]]]) = ii
    colnames(model.param[[temp.names[jj]]]) = c("Depth", "a", "b","r2")
    model.param=yearbyelement(model.param)

  }
      model.param=yearbyelement(model.param)

  Nitrate.model[[ii]]=model.param
}


temp.df=data.frame(matrix(data=NA, ncol=5, nrow=1))
colnames(temp.df) = colnames((model.param[[temp.names[1]]]))
Nitrate.model.df=data.frame(matrix(data=NA, ncol=5, nrow=40*3))
colnames(Nitrate.model.df) = colnames((model.param[[temp.names[1]]]))
ll=seq(from=1, to=nrow(Nitrate.model.df), by=length(Nitrate.model[[1]]))
       
       for (ii in 1:length(Nitrate.model)){
         for (jj in 1:length(Nitrate.model[[ii]])){
           temp.df=Nitrate.model[[ii]][[jj]]
           Nitrate.model.df[ll[ii]+jj-1,1:5]=format(temp.df, digits=10)
           Nitrate.model.df[ll[ii]+jj-1,5]=temp.df$Year
         }
       }

```

```{r parameter estimation7, echo=FALSE, warning=FALSE, message=FALSE}
R2=expression(R^{2})
d=ggplot(Nitrate.model.df, aes(x=factor(as.integer(Depth)), y=r2, colour=Year))+geom_point()
d=d+labs(title=paste("Nitrate Linear Modeling from:", min.date ,"to", max.date) ,x = "Depth", y = "r2")
d=d+scale_x_discrete("Depth", breaks=seq(from=0, to=40, by=5))
d=d+scale_y_discrete(R2, breaks=seq(0, to=1, by=0.05))
d


d=ggplot(Nitrate.model.df, aes(x=as.double(b), y=as.double(a), colour=r2, shape=Year))+geom_point()
d=d+labs(title=paste("Nitrate Linear Modeling from:", min.date ,"to", max.date) ,x = "b", y = "a")
col.breaks=seq(from=0.4, to=max(as.double(Nitrate.model.df$r2)), by=0.05)
d=d+scale_color_discrete(name=R2,breaks=c(col.breaks), labels=as.character(c(col.breaks)))
d


```

```{r parameter estimation6, echo=FALSE, warning=FALSE, message=FALSE}

x.depth=seq(from=1, to=40, by=1)
data.for.model=vector(mode = "list", length=0)

for (ii in 1:length(x.depth)){
  depth.indices=which(match(data1.split.interp.quant.df$Depth,x.depth[ii])==1)
  data.for.model[[x.depth[ii]]]=data1.split.interp.quant.df[depth.indices,]
}
# remove empty elements from list
data.for.model[sapply(data.for.model, is.null)] =NULL

#define min and max date for modelling
min.date=as.Date("2010-04-30")
max.date=as.Date("2010-12-01")

# initialize empty lists for model parameters collection
lm.NH4=vector("list", length=0)
model.param=vector("list", length=0)
NH4.model=vector("list", length=0)

for (ii in 1:length(x.depth)){
  temp=datesegmenter(min.date=min.date, max.date=max.date, input=as.data.frame(data.for.model[[x.depth[ii]]]), first.data.col=3)
  
  # assign the year to each measurment
  temp2=yearassigner(input=temp)
  
  # split the data set into a "season-based" list
  #temp3=datesplitter(temp2,min.date=min.date,max.date=max.date)
  temp3=split(temp2,f=temp2$Year)
  
  # cahnge the year value by element name for following plotting with ggplot
 # temp3=yearbyelement(input=temp3)
  
  # find the time [in days] between measurments
  datedif=datedifference(temp3)
  
  # attach the data-difference vector to the list
  data.for.model.loop=vector("list", length=0)
  names=names(temp3)
  
  for (jj in 1:length(temp3)){
    data.for.model.loop[[names[jj]]]=as.data.frame(cbind(temp3[[jj]],datedif[[2]][[jj]]))
    names(data.for.model.loop[[jj]])[names(data.for.model.loop[[jj]]) == 'V1'] = 'Date_seq'
  }
  
  # remove empty elements from list
  data.for.model.loop[sapply(data.for.model.loop, is.null)] =NULL
  
  temp.names=names(temp3)
  for (jj in 1:length(temp.names)){
    lm.NH4[[temp.names[jj]]]=lm(temp3[[jj]]$NH4~unlist(datedif[[2]][[jj]]))
    
    a = format(coef(lm.NH4[[jj]])[1], digits = 2, scientific=TRUE)
    b = format(coef(lm.NH4[[jj]])[2], digits = 2, scientific=TRUE)
    r2 = format(summary(lm.NH4[[jj]])$r.squared, digits = 2)
    
    model.param[[temp.names[jj]]]=data.frame(ii,a,b,r2)
    rownames(model.param[[temp.names[jj]]]) = ii
    colnames(model.param[[temp.names[jj]]]) = c("Depth", "a", "b","r2")
    model.param=yearbyelement(model.param)
    
  }
  model.param=yearbyelement(model.param)
  
  NH4.model[[ii]]=model.param
}


temp.df=data.frame(matrix(data=NA, ncol=5, nrow=1))
colnames(temp.df) = colnames((model.param[[temp.names[1]]]))
NH4.model.df=data.frame(matrix(data=NA, ncol=5, nrow=40*4))
colnames(NH4.model.df) = colnames((model.param[[temp.names[1]]]))
ll=seq(from=1, to=nrow(NH4.model.df), by=length(NH4.model[[1]]))

for (ii in 1:length(NH4.model)){
  for (jj in 1:length(NH4.model[[ii]])){
    temp.df=NH4.model[[ii]][[jj]]
    NH4.model.df[ll[ii]+jj-1,1:5]=format(temp.df, digits=10)
    NH4.model.df[ll[ii]+jj-1,5]=temp.df$Year
  }
}

```

```{r parameter estimation5, echo=FALSE, warning=FALSE, message=FALSE}
R2=expression(R^{2})
d=ggplot(NH4.model.df, aes(x=factor(as.integer(Depth)), y=r2, colour=Year))+geom_point()
d=d+labs(title=paste("NH4 Linear Modeling from:", min.date ,"to", max.date) ,x = "Depth", y = "r2")
d=d+scale_x_discrete("Depth", breaks=seq(from=0, to=40, by=5))
d=d+scale_y_discrete(R2, breaks=seq(0, to=1, by=0.05))
d


#d=ggplot(NH4.model.df, aes(x=factor(as.integer(Depth)), y=r2, colour=factor(a)))+geom_point()
#d=d+labs(title=paste("NH4 Linear Modeling from:", min.date ,"to", max.date) ,x = "Depth", y = "r2")
#d=d+scale_x_discrete("Depth", breaks=seq(from=0, to=40, by=5))
#d=d+scale_y_discrete(R2, breaks=seq(0, to=1, by=0.05))
#col.breaks=factor(sort(as.integer(NH4.model.df$a)))
#col.breaks=col.breaks[as.integer(seq(from=1, to=160, length.out=5))]
#d=d+scale_color_discrete(name="a",breaks=c(col.breaks), labels=as.character(c(col.breaks)))
#d

d=ggplot(NH4.model.df, aes(x=as.double(b), y=as.double(a), colour=r2, shape=Year))+geom_point()
d=d+labs(title=paste("NH4 Linear Modeling from:", min.date ,"to", max.date) ,x = "b", y = "a")
col.breaks=seq(from=0.4, to=max(as.double(NH4.model.df$r2)), by=0.05)
d=d+scale_color_discrete(name=R2,breaks=c(col.breaks), labels=as.character(c(col.breaks)))
d


```
