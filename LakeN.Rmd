---
title: "LakeN"
author: "Yoav Ben Dor"
date: "6.12.2016"
output: pdf_document
---

```{r setup, echo=FALSE ,include=FALSE , root.dir="F:/MyDocuments/GIT/LakeN", out.width = '600px', out.height = '300px'}
knitr::opts_chunk$set(echo = FALSE , warning=FALSE, message=FALSE)

# at home
#setwd("F:/MyDocuments/GIT/LakeN/R")

# at HUJI
setwd("C:/Users/user/Documents/LakeN/R")

source('depthinterp.R')
source('realdepth.R')
source('conctoquant.R')
source('daytoseason.R')
source('datesegmenter.R')
source('datedifference.R')
source('yearsegmenter.R')
source('yearassigner.R')
source('fitequation.R')
source('datesplitter.R')
source('yearbyelement.R')
source('findoxycline.R')


# at home
# setwd("F:/MyDocuments/GIT/LakeN")
# at HUJI
setwd("C:/Users/user/Documents/LakeN")

```

# Introduction

This model was written as a project for course 68806: Eco-hydrologic modelling with R, Hebrew University of Jerusalem.

The purpose of this model is to illustrate the annual N cycle in a lake in northern Israel, and to simulate the transitions between two dominant N species: Nitrate $(NO_3)$ and Ammonium $(NH_4^+)$

# Key terms

### Nitrate
$$NO_3$$

### Nitrite
$$NO_2^-$$

### ammonia
$$NH_3$$


### ammonium
$$NH_4^+$$

### Hypolimion
The lower layer of water in a stratified lake, typically cooler than the water above and relatively stagnant. develops anoxic condition due to limited interaction with the atmosphere

### Epilimion
The upper layer of water in a stratified lake, which remains oxygenated throughout the year.

### Thermocline
A steep temperature gradient in a body of water such as a lake, marked by a layer above and below which the water is at different temperatures. Because warmer water are less dense, the thermocline dictates the mixing depth of the lake, and therefore directly determine chemical properties of the lake's layers. In the studied lake, the developing thermocline closely coincides with the oxycline and chemocline.

### Oxycline
The layer that encompasses a sharp gradient in oxygen concentration in the lake.

### Nitrification

Nitrification includes the oxidation of ammonia into nitrite in a two-stage process, initiated by the nitrosomonas bacteria, and followed by the oxidation of nitrate by nitrobacteria. The process can be summarized as: $$NH_4^+ →NH_3→NO_2^-→NO_3$$

This process largely depends on oxygen availability, ambient conditions and the size of bacterial populations. The process has been documented to be carried quickly and directly into nitrate in some years, whereas in others the increase in nitrite preceded the transformation into nitrate by several days and up to a couple of weeks.

Nitrification takes places in oxic conditions, and largely depends on the mixing of the water column during the winter. It is halted in the hypolimnion during the well-stratified conditions that develop from spring to autumn, and reignites in winter, when the lake is fully mixed. Nitrification is however still possible in the interface of the hypolimnion with the epilimnion, where dissolved oxygen is present to some extent. Nitrate concentrations are highest at the end of January after a fuul mixing of the lake is achieved, in addition to riverborn nitrate that originates from fertilization and soils.

### Ammonification

Ammonification is the process by which organic biomass nitrogen is recycled after creatures death. Ammonification is carried out by a diverse array of microorganisms that perform ecological decay services, and its product is ammonia or ammonium ion. Ammonium buildsup during anoxic conditions that form in the developing hypolimnion between spring and autumn. Ammonium is a suitable source of nutrition for many species of algae, and is therefore readily consumed upon lake mixing and its injection into the photic zone during winter.

## Background

Anthropogenic effects during recent years had largely affected the nitrogen cycle in the lake during the last decades. Increased N inputs, primarily as river-born nitrate, originating in soils and fertilization, strengthen eutrophication, anoxic conditions and blooms of harmful algae, thus interrupting the ecological cycle.

The nitrogen cycle includes several key processes, which include the cycling between several species which dictate its bioavailability and importance in biogeochemical processes. Rivers are efficient N sinks, but in its inorganic forms, it is removed from the water through assimilation and adsorption onto sediments.

In the studied lake, an N-fixing algae of the cyanobacteria phylum appeared for the first time during the autumn of 1994. It reappears every year since that time, and was recently accompanied by another cyanobacteria specie since 2005. This dramatic change in lake ecology is the likely result of changes in the availability of water-soluble nutrients, which provided the N-fixing species with a relative ecological advantage.

It is important to remember that the measurment process provides a "snapshot" of lake conditions in a specific time, and that all coocuring processes form interchanging fluxes of nitrogen between the various nitrogen pools. While the modelling of the molecular process is difficult to configure, because it involves complex biological processes, the net transformation of species between pools can be modelled through a "net-gross" approach, where molecular transformations are summed into simplistic, time-dependent processes, that are arithmatically disconnected. If each of these processes can be adequately modelled following simplistic time-dependant equations, the N cycle can be modelled in terms of net fluxes, without taking into account all possible processes and their complexities.

## The N cycle

Several key process dominate the N cycle of the studied lake. These include nitrification, denitrification, the fixation of atmospheric nitrogen by cycanobacteria and N recycling through consumption of primary producer up the food chasin. Nitrate and ammonium are constantly consumed by primary producers that are consequently consumed by grazers. The following ecological food chain serves as an endless conveyor that recycles nitrogen through the lake.

These  processes are inherintly biologically mediated, and their relative role in the transformation of one specie to another greatly depends on ambient conditions such as radiation and temperature, as well as other chemical properties, and oxygen content in particular, which are largely dependent on its limnological cycle. The consideration of these parameters in a limnological perspective is essential for the consideration of the dominant processes and their ecological impact.

### References

Nitrogen Cycle - Ammonification And Nitrification - Ammonium, Bacteria, Nitrate, and Acidic - JRank Articles http://science.jrank.org/pages/4690/Nitrogen-Cycle-Ammonification-nitrification.html#ixzz4U1Rm3S3A

# About thist model

In this model I examine the possibility to model the transition between oxydized and reduced species in the lake using a very simplistic approach. Due to the complexity of the processes, and the plethora of available data, the simplistic approach in this model relies on four key processes to model the nitrate-ammonioum transitions:

1. Nitrate build-up during lake stratification in the epylimnion
2. Ammonification build-up during lake stratification in the hypolimnion
3. Lake mixing
4. Nitrate consumption following lake mixing
5. Ammonium consumption following lake mixing

This model provides the oppertunity to examine wether these processes suffice to model the dominant segments of the N cycle, or should a more complex, biologically-oriented approach be adopted to configure the N cycle properly.

------

## Data preparation

The data is provided in discrete form of concentration measurments. The depths of the measurments are not constant, and the time intervals between measurments are also not constant, and range from several days to several weeks.

### read the data and load relevant libraries

```{r data read, echo=FALSE, warning=FALSE, message=FALSE, out.width = '600px', out.height = '300px'}
# load relevant libraries
library(plyr)
library(zoo)
library(dplyr)
library(LakeN)
library(plot3D)
library(ggplot2)
library(png)
library(reshape2)

# read the data for the model
# use the read.table function in the cas of a tab=delimited text file
# use the read.csv function for a csv

# data1 - measured gecochmical profiles
data1=read.table("LakeNData1.txt", header=TRUE)

# data2 - lake hypsometric curve including depth to area transformation
data2=read.table("LakeNData2.txt", header=TRUE)

# data3 - lake level measurments for depth corrections
data3=read.table("LakeNData3.txt", header=TRUE)

# data1 - temperature profile measurments
data4=read.table("LakeNData4.txt", header=TRUE)

# split the data set by measurment date
data1.split.orig=split(data1, f=data1$Date)

# fill NA cells with linear interpolation in original data
# initilize list to be filled
data1.split=vector("list", length(data1.split.orig))

first.data.col=3
dates=as.Date(unique(data1$Date, incomparables = FALSE))

for (ii in 1:length(data1.split.orig)){
  temp.df=data1.split.orig[[ii]]
  
  #find columns that are all NA and zero fill them prior to interpolation
  zero.index=NA
  zero.index=which(sapply(temp.df, function(x)all(is.na(x))))
  if (is.integer(zero.index)){
    temp.df[,zero.index]=c(rep.int(0, times=nrow(temp.df)))}
  
  # fill NA values confined between numbers using linear interoplation
  for (jj in first.data.col:ncol(temp.df)){
    app.var=as.double(na.approx(x=temp.df$Depth,as.numeric(unlist(temp.df[,jj])), method="linear",na.rm=FALSE))
    # remove NA values that are not confined between numbers with nearest value
    temp.df[,jj]=as.double(na.locf(na.locf(app.var,na.rm=FALSE),na.rm=FALSE, fromLast=TRUE))
  }
  
  #assign the interpolated values into the results list
  temp.name=as.character.Date(dates[ii])
  data1.split[[temp.name]]=data.frame(temp.df)
  rm(temp.df)
}

#remove any empty elemts of the list
data1.split[which(names(data1.split) %in% c(""))]=NULL

summary(data1)

```

\newpage

## Interpolate the Data into 1 m Intervals

Use the function "depthinterp"" to interpolate the data into uniform length for every 1 m. This is essential for later calculating the volume of each depth interval and the mass of each N specie measured in this depth.

```{r interpolation, echo=FALSE, warning=FALSE, message=FALSE, out.width = '600px', out.height = '300px'}

#define matrix size requiered for interpolating the data
n.col.interp=ncol(data1.split[[1]])
n.row.interp=40

#extract unique date values of measurments to be used for real level correction
dates=as.Date(unique(data1$Date, incomparables = FALSE))

# initialize an empty data frame for interpolation results
data1.split.interp=vector("list", length=0)

# run interpolation function for each element
for (ii in 1:length(data1.split)){
  temp=depthinterp(input=na.locf(data1.split[[ii]]))
  temp.name=as.character.Date(dates[ii])
  data1.split.interp[[temp.name]]=data.frame(temp)
}
#remove any empty elemts of the list
data1.split.interp[which(names(data1.split.interp) %in% c(""))]=NULL
```

### Demonstrate interpolations of randomly selected data

```{r interpolation plots, echo=FALSE, warning=FALSE, message=FALSE, out.width = '600px', out.height = '300px'}
# choose a random number to demonstrate the interpolation
rand.num=sample(1:length(data1.split),1)
rand.date=as.character.Date(dates[rand.num])

plot(data1.split[[rand.date]]$Oxygen,data1.split[[rand.date]]$Depth,  
     main=paste("Oxygen interpolation", rand.date),ylab="Depth [m]", xlab="Oxygen [mol/l]",
     ylim=rev(range(data1.split.interp[[rand.num]]$Depth)),
     xlim=c(0, as.double(max(data1.split[[rand.num]]$Oxygen))))
lines(data1.split.interp[[rand.date]]$Oxygen,data1.split.interp[[rand.date]]$Depth,  col=2)

#place a legend for an oxygen plot
legend(0, 1, c("Measured", "Interpolation"), col = c(1, 2),
       lty = c(NA,1), pch = c(1, NA),
       merge = TRUE, bg = "gray90")

plot(data1.split[[rand.date]]$Nitrate,data1.split[[rand.date]]$Depth,  
     main=paste("N species interpolation", rand.date),ylab="Depth [m]", xlab="Nitrate/NH4 [mol/l]",
     ylim=rev(range(data1.split.interp[[rand.date]]$Depth)), xlim=c(0,1.5*as.double(max(c(range(data1.split[[rand.date]]$Nitrate),range(data1.split[[rand.date]]$NH4))))), col=1)

lines(data1.split.interp[[rand.date]]$Nitrate,data1.split.interp[[rand.date]]$Depth,  col=2)
points(data1.split[[rand.date]]$NH4,data1.split[[rand.date]]$Depth, col=3)
lines(data1.split.interp[[rand.date]]$NH4,data1.split.interp[[rand.date]]$Depth,  col=4)

#place a legend for a geochemical plot
legend(1.05*as.double(max(c(max(data1.split[[rand.num]]$Nitrate),max(data1.split[[rand.num]]$NH4)))), 1, c("Measured NO2", "Interpolation","Measured NH4", "Interpolation"), col = c(1, 2,3,4),
       lty = c(NA,1,NA,1), pch = c(1,NA,1,NA),
       merge = TRUE, bg = "gray90")

```

## Depth and Level Corrections
Calculate the appropriate depth for each measurment using available daily level measurments. Use function "realdepth" and use closest day if no level measurment of that day is available. This correction is essential for later calculation of depth to volume and concentration quantification of N species in the lake.

```{r level-depth correction, echo=FALSE, warning=FALSE, message=FALSE, out.width = '600px', out.height = '300px'}
# this block arranges the depth of the measurments according to the lake level during that day

# initialize a data frame to accept the corrected data
data1.split.interp.depth=vector("list", length=0)
data1.split.depth=vector("list", length=0)

# run depth correction function for each element
for (ii in 1:length(dates)){
  temp.date=as.character.Date(dates[ii])
  temp=realdepth(depth.date=data3, measurment.date=temp.date, input=data1.split.interp[[temp.date]])
  data1.split.interp.depth[[temp.date]]=data.frame(temp)
  
  temp=realdepth(depth.date=data3, measurment.date=temp.date, input=data1.split[[temp.date]])
  data1.split.depth[[temp.date]]=data.frame(temp)
}
#remove any empty elemets of the list
data1.split.depth[which(names(data1.split.depth) %in% c(""))]=NULL
data1.split.interp.depth[which(names(data1.split.interp.depth) %in% c(""))]=NULL
```

### demonstrate the results according to the new depth scale of randomly selected data
```{r level-depth correction plots, echo=FALSE, warning=FALSE, message=FALSE, out.width = '600px', out.height = '300px'}
# choose a random number to demonstrate the interpolation
rand.num=sample(1:length(data1.split),1)
rand.date=as.character.Date(dates[rand.num])

plot(data1.split.depth[[rand.date]]$Oxygen,data1.split.depth[[rand.date]]$Depth,  
     main=paste("Oxygen interpolation", rand.date),ylab="Depth [m]", xlab="Oxygen [mol/l]",
     ylim=range(data1.split.interp.depth[[rand.num]]$Depth), xlim=c(0, max(as.double(data1.split[[rand.date]]$Oxygen))))
lines(data1.split.interp.depth[[rand.date]]$Oxygen,data1.split.interp.depth[[rand.date]]$Depth,  col=2)

#place a legend for an oxygen plot
legend(0, as.double(max(data1.split.interp.depth[[rand.num]]$Depth)), c("Measured", "Interpolation"), col = c(1, 2),lty = c(NA,1), pch = c(1, NA), merge = TRUE, bg = "gray90")

plot(data1.split.depth[[rand.date]]$Nitrate,data1.split.depth[[rand.date]]$Depth,  
     main=paste("N species interpolation", rand.date),ylab="Depth [m]", xlab="Nitrate/NH4 [mol/l]",
     ylim=range(data1.split.interp.depth[[rand.date]]$Depth), xlim=c(0,1.5*max(c(max(as.double((data1.split[[rand.date]]$Nitrate))),max(as.double(data1.split[[rand.date]]$NH4))))), col=1)
lines(data1.split.interp.depth[[rand.date]]$Nitrate,data1.split.interp.depth[[rand.date]]$Depth,  col=2)
points(data1.split.depth[[rand.date]]$NH4,data1.split.depth[[rand.date]]$Depth, col=3)
lines(data1.split.interp.depth[[rand.date]]$NH4,data1.split.interp.depth[[rand.date]]$Depth,  col=4)

#place a legend for a geochemical plot
legend(1.05*max(c(max(as.double(data1.split[[rand.num]]$Nitrate)),max(as.double(data1.split[[rand.num]]$NH4)))), max(data1.split.interp.depth[[rand.num]]$Depth), c("Measured NO2", "Interpolation","Measured NH4", "Interpolation"), col = c(1, 2,3,4),lty = c(NA,1,NA,1), pch = c(1,NA,1,NA),merge = TRUE, bg = "gray90")

```

## Quantify the data using lake hypsometric curve

The use of concentrations has limitiations because it may enhance or demise a processes that is inhernently "mass-based".Quantify the amount of measured species using the hypsomentric curve of the lake using function "conctoquant". Multiply each depth value with its corresponding hypsometric value to  
```{r quntification, echo=FALSE, warning=FALSE, message=FALSE, out.width = '600px', out.height = '300px'}
# this block calculates the total amount using the hypsometric curve of the lake

# initialize a data frame to accept the corrected data
data1.split.interp.depth.quant=vector("list", length=0)
data1.split.depth.quant=vector("list", length=0)

# run quantification function for each element
for (ii in 1:length(dates)){
  temp.date=as.character.Date(dates[ii])
  temp=conctoquant(hypso.curve=data2, input=data1.split.interp.depth[[temp.date]])
  data1.split.interp.depth.quant[[temp.date]]=data.frame(temp)
  
  temp=conctoquant(hypso.curve=data2, input=data1.split.depth[[temp.date]])
  data1.split.depth.quant[[temp.date]]=data.frame(temp)

}
#remove any empty elemts of the list
data1.split.interp.depth.quant[which(names(data1.split.interp.depth.quant) %in% c(""))]=NULL
data1.split.depth.quant[which(names(data1.split.depth.quant) %in% c(""))]=NULL

km2=xlab=expression(Km^{2})

xlab=paste("Area [",km2,"]", collapse=" ")

plot(data2$SA,data2$WD,main=paste("Lake hypsometric curve"),ylab="Depth [m]", xlab=km2,
     ylim=(range(data2$WD)), xlim=range(data2$SA))

```

### demonstrate the results according to the new depth scale of randomly selected data
```{r quntification plots, echo=FALSE, warning=FALSE, message=FALSE, out.width = '600px', out.height = '300px'}
# choose a random number to demonstrate the interpolation
rand.num=sample(1:length(data1.split),1)
rand.date=as.character.Date(dates[rand.num])

plot(data1.split.depth.quant[[rand.date]]$Oxygen,data1.split.depth.quant[[rand.date]]$Depth,  
     main=paste("Oxygen interpolation", rand.date),ylab="Depth [m]", xlab="Oxygen [quant]",
     ylim=range(data1.split.interp.depth[[rand.num]]$Depth), xlim=c(0, max(as.double(data1.split.depth.quant[[rand.date]]$Oxygen))))
lines(data1.split.interp.depth.quant[[rand.date]]$Oxygen,data1.split.interp.depth.quant[[rand.date]]$Depth,  col=2)

#place a legend for an oxygen plot
legend(0, max(as.double(data1.split.interp.depth.quant[[rand.num]]$Depth)), c("Measured", "Interpolation"), col = c(1, 2),lty = c(NA,1), pch = c(1, NA), merge = TRUE, bg = "gray90")

plot(data1.split.depth.quant[[rand.date]]$Nitrate,data1.split.depth.quant[[rand.date]]$Depth,  
     main=paste("N species interpolation", rand.date),ylab="Depth [m]", xlab="Nitrate/NH4 [quant]",
     ylim=range(data1.split.interp.depth[[rand.date]]$Depth), xlim=c(0,1.5*max(c(max(as.double(data1.split.depth.quant[[rand.date]]$Nitrate),max(as.double(data1.split.depth.quant[[rand.date]]$NH4)))))), col=1)

lines(data1.split.interp.depth.quant[[rand.date]]$Nitrate,data1.split.interp.depth.quant[[rand.date]]$Depth,  col=2)

points(data1.split.depth.quant[[rand.date]]$NH4,data1.split.depth.quant[[rand.date]]$Depth, col=3)

lines(data1.split.interp.depth.quant[[rand.date]]$NH4,data1.split.interp.depth.quant[[rand.date]]$Depth,  col=4)

#place a legend for a geochemical plot
legend(1.05*max(c((data1.split.depth.quant[[rand.num]]$Nitrate),max(data1.split.depth.quant[[rand.num]]$NH4))), -215, c("Measured NO2", "Interpolation","Measured NH4", "Interpolation"), col = c(1, 2,3,4),lty = c(NA,1,NA,1), pch = c(1,NA,1,NA),merge = TRUE, bg = "gray90")

```


```{r data frame creation, echo=FALSE, warning=FALSE, message=FALSE, out.width = '600px', out.height = '300px'}
# create a dataframe based on interpolated data in list
# load the first element of the list
data1.split.interp.depth.quant.df=as.data.frame(data1.split.interp.depth.quant[[1]])
oxygen.concentration.interp=as.data.frame(data1.split.interp.depth[[1]]$Oxygen)
colnames(oxygen.concentration.interp)=c("Oxygen")

# load all other elements in a loop
for (ii in 2:length(data1.split.interp.depth.quant)){
  temp=as.data.frame(data1.split.interp.depth.quant[[ii]])
  temp.ox=as.data.frame(data1.split.interp.depth[[ii]]$Oxygen)
  colnames(temp.ox)=c("Oxygen")
  
  data1.split.interp.depth.quant.df=rbind(data1.split.interp.depth.quant.df,temp)
  oxygen.concentration.interp=rbind(oxygen.concentration.interp,temp.ox)
}
colnames(oxygen.concentration.interp)=c("Oxygen_conc")

data1.split.interp.depth.quant.df=cbind(data1.split.interp.depth.quant.df,oxygen.concentration.interp)

#create a data frame where depth values are 1 to 40
data1.split.interp.quant.df=data1.split.interp.depth.quant.df
data1.split.interp.quant.df[["Depth"]]=rep(seq(from=1, to=40, by=1),length(data1.split.interp.quant.df[["Depth"]])/40)
data1.split.interp.quant.df=cbind(data1.split.interp.quant.df,oxygen.concentration.interp)

# calculate matching season for every measurment day
day.season=data.frame(matrix(data=NA, ncol=2, nrow=length(data1.split.interp.quant.df)))
day.season=daytoseason(input=data1.split.interp.quant.df$Date)

data1.split.interp.quant.df=cbind(data1.split.interp.quant.df,day.season[,2:3])
data1.split.interp.depth.quant.df=cbind(data1.split.interp.depth.quant.df,day.season[,2:3])
```

## Time series plots

The following plots provide some visual estimation of the data to visualize time-depth processes for further considerations for the modelling of the processes

```{r time series visualization, echo=FALSE, warning=FALSE, message=FALSE, out.width = '600px', out.height = '300px'}

# create x (date) and y (depth) vectors for plots
x= as.numeric(data1.split.interp.depth.quant.df$Date)
dim(x)=c(40,length(x)/40)
y= rep(seq(from=1, to=40, by=1), length(x)/40)
dim(y)=c(40,length(y)/40)

# uncomment these lines for absolute depth y axis
# remember to remove rev command from image2d

# y= as.numeric(data1.split.interp.depth.quant.df$Depth)
# dim(y)=c(40,length(y)/40)

# calculate the oxycline depth
oxycline.depth=findoxylcline(input=data1.split.interp, oxygen.data.col=9, threshold = 0.85, depth.interval=12,smooth.param=0.09)

# plot Oxygen values
z= data1.split.interp.depth.quant.df$Oxygen
dim(z)=c(40,length(z)/40)
image2D(z,x,y, main="Oxygen [amount]",xlab='',ylab="depth [m]",ylim=rev(range(y)),xaxt="n")
r <- as.POSIXct(range(data1.split.interp.depth.quant.df$Date), "weeks")
axis.Date(1, at = seq(r[1], r[2], by = "month"), format = "%m-%Y")

# plot Oxygen concentration values
z=oxygen.concentration.interp
z=matrix(as.matrix(oxygen.concentration.interp), nrow=40, ncol=nrow(z)/40)
image2D(z,x,y, main="Oxygen [concentration]",xlab='',ylab="depth [m]",ylim=rev(range(y)),xaxt="n")
r <- as.POSIXct(range(data1.split.interp.depth.quant.df$Date), "weeks")
axis.Date(1, at = seq(r[1], r[2], by = "month"), format = "%m-%Y")
#lines(unique(x),oxycline.depth[[1]] ,col="white",lwd=2)
lines(unique(x),oxycline.depth[[2]] ,col="red",lwd=2)


# plot Nitrate values
z= data1.split.interp.depth.quant.df$Nitrate
dim(z)=c(40,length(z)/40)
image2D(z,x,y, main="Nitrate [amount]",xlab='',ylab="depth [m]",ylim=rev(range(y)),xaxt="n")
r <- as.POSIXct(range(data1.split.interp.depth.quant.df$Date), "weeks")
axis.Date(1, at = seq(r[1], r[2], by = "month"), format = "%m-%Y")

# plot NH4 values
z= data1.split.interp.depth.quant.df$NH4
dim(z)=c(40,length(z)/40)
image2D(z,x,y, main="NH4 [amount]",xlab='',ylab="depth [m]",ylim=rev(range(y)),xaxt="n")
r <- as.POSIXct(range(data1.split.interp.depth.quant.df$Date), "weeks")
axis.Date(1, at = seq(r[1], r[2], by = "month"), format = "%m-%Y")

# plot Norparticular values
z= data1.split.interp.depth.quant.df$Norg_par
dim(z)=c(40,length(z)/40)
image2D(z,x,y, main="N Organic particular [amount]",xlab='',ylab="depth [m]",ylim=rev(range(y)),xaxt="n")
r <- as.POSIXct(range(data1.split.interp.depth.quant.df$Date), "weeks")
axis.Date(1, at = seq(r[1], r[2], by = "month"), format = "%m-%Y")

# plot Ntot values
z= data1.split.interp.depth.quant.df$Ntot
dim(z)=c(40,length(z)/40)
image2D(z,x,y, main="Total N [amount]",xlab='',ylab="depth [m]",ylim=rev(range(y)),xaxt="n")
r <- as.POSIXct(range(data1.split.interp.depth.quant.df$Date), "weeks")
axis.Date(1, at = seq(r[1], r[2], by = "month"), format = "%m-%Y")


```

## Time-depth cross sections

```{r time-depth sections, echo=FALSE, warning=FALSE, message=FALSE, out.width = '600px', out.height = '300px'}

# plot a section through the data
x.depth=seq(from=5, to=40, by=5)

#initilize Oxygen plot
depth.indices=which(match(data1.split.interp.quant.df$Depth,x.depth[1])==1)
pox=ggplot(data=data1.split.interp.quant.df[depth.indices,], aes(x=Date, y=Oxygen, colour=Depth))+geom_line()
pox=pox+labs(title="Oxygen" ,x = "Month", y = "Oxygen[quant]")
pox=pox+scale_x_date(date_labels="%m-%Y", date_breaks="6 months")
pox=pox+scale_colour_gradient2(low = "red", mid = "green" , high = "blue", midpoint = 20)

for (ii in 2:length(x.depth)){
  depth.indices=which(match(data1.split.interp.quant.df$Depth,x.depth[ii])==1)
  pox=pox+geom_line(data=data1.split.interp.quant.df[depth.indices,], aes(x=Date, y=Oxygen, colour=Depth))
}
pox

#initilize Oxygen plot
depth.indices=which(match(data1.split.interp.quant.df$Depth,x.depth[1])==1)
pox=ggplot(data=data1.split.interp.quant.df[depth.indices,], aes(x=Date, y=Oxygen_conc, colour=Depth))+geom_line()
pox=pox+labs(title="Oxygen" ,x = "Month", y = "Oxygen[conc]")
pox=pox+scale_x_date(date_labels="%m-%Y", date_breaks="6 months")
pox=pox+scale_colour_gradient2(low = "red", mid = "green" , high = "blue", midpoint = 20)

for (ii in 2:length(x.depth)){
  depth.indices=which(match(data1.split.interp.quant.df$Depth,x.depth[ii])==1)
  pox=pox+geom_line(data=data1.split.interp.quant.df[depth.indices,], aes(x=Date, y=Oxygen_conc, colour=Depth))
}
pox


#initilize Nitrate plot
depth.indices=which(match(data1.split.interp.quant.df$Depth,x.depth[1])==1)
pnit=ggplot(data=data1.split.interp.quant.df[depth.indices,], aes(x=Date, y=Nitrate, colour=Depth))+geom_line()
pnit=pnit+labs(title="Nitrate" ,x = "Month", y = "Nitrate[quant]")
pnit=pnit+scale_x_date(date_labels="%m-%Y", date_breaks="6 months")
pnit=pnit+scale_colour_gradient2(low = "red", mid = "green" , high = "blue", midpoint = 20)

for (ii in 2:length(x.depth)){
  depth.indices=which(match(data1.split.interp.quant.df$Depth,x.depth[ii])==1)
  pnit=pnit+geom_line(data=data1.split.interp.quant.df[depth.indices,], aes(x=Date, y=Nitrate, colour=Depth))
}
pnit

#initilize NH4 plot
depth.indices=which(match(data1.split.interp.quant.df$Depth,x.depth[1])==1)
pnh4=ggplot(data=data1.split.interp.quant.df[depth.indices,], aes(x=Date, y=NH4, colour=Depth))+geom_line()
pnh4=pnh4+labs(title="NH4" ,x = "Month", y = "NH4[quant]")
pnh4=pnh4+scale_x_date(date_labels="%m-%Y", date_breaks="6 months")
pnh4=pnh4+scale_colour_gradient2(low = "red", mid = "green" , high = "blue", midpoint = 20)
for (ii in 2:length(x.depth)){
  depth.indices=which(match(data1.split.interp.quant.df$Depth,x.depth[ii])==1)
  pnh4=pnh4+geom_line(data=data1.split.interp.quant.df[depth.indices,], aes(x=Date, y=NH4, colour=Depth))
}
pnh4

```

## Correlation plots

The following plots provide some visual estimation of data correlation

```{r correlation plots, echo=FALSE, warning=FALSE, message=FALSE, out.width = '600px', out.height = '300px'}

d=ggplot(data=data1.split.interp.quant.df, aes(x=Oxygen, y=Nitrate, colour=Depth, shape=Season))+geom_point()
d=d+scale_colour_gradient2(low = "red", mid = "green" , high = "blue", midpoint = 20)
d=d+labs(title=paste("Nitrate vs. Oxygen"),x = "Oxygen [quant]", y = "Nitrate[quant]")
d

d=ggplot(data=data1.split.interp.quant.df, aes(x=Oxygen_conc, y=Nitrate, colour=Depth, shape=Season))+geom_point()
d=d+scale_colour_gradient2(low = "red", mid = "green" , high = "blue", midpoint = 20)
d=d+labs(title=paste("Nitrate vs. Oxygen"),x = "Oxygen [conc]", y = "Nitrate[quant]")
d

d=ggplot(data=data1.split.interp.quant.df, aes(x=Oxygen, y=NH4, colour=Depth, shape=Season))+geom_point()
d=d+scale_colour_gradient2(low = "red", mid = "green" , high = "blue", midpoint = 20)
d=d+labs(title=paste("NH4 vs. Oxygen"),x = "Oxygen [quant]", y = "NH4[quant]")
d

d=ggplot(data=data1.split.interp.quant.df, aes(x=Oxygen_conc, y=NH4, colour=Depth, shape=Season))+geom_point()
d=d+scale_colour_gradient2(low = "red", mid = "green" , high = "blue", midpoint = 20)
d=d+labs(title=paste("NH4 vs. Oxygen"),x = "Oxygen [conc]", y = "NH4[quant]")
d

d=ggplot(data=data1.split.interp.quant.df, aes(x=NH4, y=Nitrate, colour=Season_ind, shape=Season))+geom_point()
d=d+scale_colour_gradient2(low = "red", mid = "green" , high = "blue", midpoint = 2)
d=d+labs(title=paste("Nitrate vs. NH4"),x = "Oxygen [quant]", y = "NH4[quant]")
d

d=ggplot(data=data1.split.interp.quant.df, aes(x=NH4, y=Nitrate, colour=Depth, shape=Season))+geom_point()
d=d+scale_colour_gradient2(low = "red", mid = "green" , high = "blue", midpoint = 20)
d=d+labs(title=paste("Nitrate vs. NH4"),x = "Oxygen [quant]", y = "NH4[quant]")
d

```

# Model fitting estimation

Nitrification and denitrification are two oposing processes that take place in the present or absence of oxygen. They therefore develop in the upper (nitrification) and lower (denitrification) parts of the lake during episodes of a stratified water column. The model therefore relies on the assumprion that their development depends on the presence of oxygen and the time available for their accumulation. Lake mixing, which takes place during winter, disrupts thier build-up, and uniformly distribute them across the lake, and mixing propagates towards the lake bottom. These two proceeses (stratification and mixing)can be examined in detail in two representative depths of 10m (nitrification) and 30m (denitrification).

```{r visual estimation of seasonal variations, echo=FALSE, warning=FALSE, message=FALSE, out.width = '600px', out.height = '300px'}
x.depth=c(10,30)
depth.for.model=vector(mode = "list", length=0)

for (ii in 1:length(x.depth)){
  depth.indices=which(match(data1.split.interp.quant.df$Depth,x.depth[ii])==1)
  depth.for.model[[x.depth[ii]]]=data1.split.interp.quant.df[depth.indices,]
}
# remove empty elements from list
depth.for.model[sapply(depth.for.model, is.null)] =NULL

#for (ii in 1:length(x.depth)){
#  depth.for.model[[x.depth[ii]]]=data1.split.interp.quant.df[depth.indices,]
#}

d=ggplot(data=as.data.frame(depth.for.model[[1]]), aes(x=Date, y=Nitrate, colour=Oxygen, shape=Season))+geom_point()

d=d+scale_colour_gradient2(low = "blue",mid = "green" , high = "red", midpoint=(max(depth.for.model[[1]]$Oxygen)-min(depth.for.model[[1]]$Oxygen))/1)
d=d+labs(title=paste("Nitrate depth:", x.depth[1],"[m]"),x = "Month", y = "Nitrate[quant]")+scale_x_date(date_labels="%m-%Y", date_breaks="6 months")
d

d=ggplot(data=as.data.frame(depth.for.model[[1]]), aes(x=Date, y=NH4, colour=Oxygen, shape=Season))+geom_point()

d=d+scale_colour_gradient2(low = "blue", mid = "green" , high = "red", midpoint=(max(depth.for.model[[1]]$Oxygen)-min(depth.for.model[[1]]$Oxygen))/1)
d=d+labs(title=paste("NH4 depth:", x.depth[1],"[m]") ,x = "Month", y = "NH4[quant]")+scale_x_date(date_labels="%m-%Y", date_breaks="6 months")
d

d=ggplot(data=as.data.frame(depth.for.model[[2]]), aes(x=Date, y=Nitrate, colour=Oxygen, shape=Season))+geom_point()

d=d+scale_colour_gradient2(low = "blue", mid = "green" , high = "red", midpoint=(max(depth.for.model[[2]]$Oxygen)-min(depth.for.model[[2]]$Oxygen))/2)
d=d+labs(title=paste("Nitrate depth:", x.depth[2],"[m]") ,x = "Month", y = "Nitrate[quant]")+scale_x_date(date_labels="%m-%Y", date_breaks="6 months")
d

d=ggplot(data=as.data.frame(depth.for.model[[2]]), aes(x=Date, y=NH4, colour=Oxygen, shape=Season))+geom_point()

d=d+scale_colour_gradient2(low = "blue", mid = "green" , high = "red", midpoint=(max(depth.for.model[[2]]$Oxygen)-min(depth.for.model[[2]]$Oxygen))/2)
d=d+labs(title=paste("NH4 depth:", x.depth[2],"[m]") ,x = "Month", y = "NH4[quant]")+scale_x_date(date_labels="%m-%Y", date_breaks="6 months")
d
```

### Process rate estimation

It can be observed from the figures presented above that nitrification is dominant in the upper portions of the lake (depicted for 10m depth), primarily between January and April, when the mixing of the lake decreases its content through a down-ward propagating mixing of the oxygenated epilimnion with the lower, oxygen-depleted hypolimnion. Ammonium, on the other hand, develops during the stratified lake conditions in its hypolimnion (depicted for depth 30 m), and peaks at the begining of May, right before the mixing of the lake reaches the deeper parts of the lake, denitrification is halted, and the deeper lake is oxygenated once more.

Simulate Nitrate build-up between November $1^{st}$ and April $30^{st}$ in 10m depth in order to estimate processes rate

```{r nitrate modelling, echo=FALSE, warning=FALSE, message=FALSE, out.width = '600px', out.height = '300px'}
# segment the data to model by dates
# the dates will be segmented into a list containing the relevant dates for every year
# if the time span ranges acrros Jan 1st, be sure to change the year in the ma.date value
temp.10=datesegmenter(min.date=as.Date("2010-01-01"), max.date=as.Date("2010-03-30"), input=as.data.frame(depth.for.model[[2]]), first.data.col=3)
# assign the year to each measurment
temp2.10=yearassigner(input=temp.10)
# split the data set into a "year-based" list
temp3.10=split(temp2.10,f=temp2.10$Year)
# split the data set into a "season-based" list
#temp3.10=datesplitter(temp2.10,min.date="2010-11-01",max.date="2011-05-01")
# cahnge the year value by element name for following plotting with ggplot
#temp3.10=yearbyelement(input=temp3.10)
# find the time [in days] between measurments
datedif.10=datedifference(temp3.10)

# attach the data-difference vector to the list
data.for.model.10=vector("list", length=0)
names.10=names(temp3.10)

for (ii in 1:length(temp3.10)){
  data.for.model.10[[names.10[ii]]]=as.data.frame(cbind(temp3.10[[ii]],datedif.10[[2]][[ii]]))
  names(data.for.model.10[[ii]])[names(data.for.model.10[[ii]]) == 'V1'] = 'Date_seq'
}

# remove empty elements from list
data.for.model.10[sapply(data.for.model.10, is.null)] =NULL

## create a dataframe based on the list for the model
# load the first element of the list
data.for.model.10.df=as.data.frame(data.for.model.10[[1]])
temp.2=data.for.model.10[[1]]
# load all other elements in a loop
for (ii in 2:length(data.for.model.10)){
  temp=as.data.frame(data.for.model.10[[ii]])
  temp.2=rbind(temp.2,temp)
}
data.for.model.10.df=temp.2

lm1.10.Nitrate=lm(temp3.10$'2011'$Nitrate~unlist(datedif.10[[2]]$'2011'))
lm2.10.Nitrate=lm(temp3.10$'2012'$Nitrate~unlist(datedif.10[[2]]$'2012'))
lm3.10.Nitrate=lm(temp3.10$'2013'$Nitrate~unlist(datedif.10[[2]]$'2013'))

eq.1=fitequation(lm1.10.Nitrate)
eq.2=fitequation(lm2.10.Nitrate)
eq.3=fitequation(lm3.10.Nitrate)

d=ggplot(data=data.for.model.10.df, aes(x=Date_seq, y=Nitrate, colour=Year))+geom_point()
d=d+labs(title=paste("Nitrate build-up depth:", x.depth[1],"[m]", "Janaury 1 to March 30") ,x = "Days from measurment", y = "Nitrate[quant]")
d=d+geom_smooth(method='lm')
d=d+geom_text(x = 20, y = 4.5E+07, label = eq.1, parse = TRUE, colour="red")
d=d+geom_text(x = 20, y = 4.0E+07, label = eq.2, parse = TRUE, colour="dark green")
d=d+geom_text(x = 20, y = 3.5E+07, label = eq.3, parse = TRUE, colour="blue")
d

```

simulate NH4 build-up between April $30^{st}$ and December $1^{st}$ in 30m depth in order to estimate reaction rate

```{r NH4 build-up modelling, echo=FALSE, warning=FALSE, message=FALSE, out.width = '600px', out.height = '300px'}
# segment the data to model by dates
# the dates will be segmented into a list containing the relevant dates for every year
temp.30=datesegmenter( min.date=as.Date("2010-04-30"),max.date=as.Date("2010-12-01"), input=as.data.frame(depth.for.model[[2]]), first.data.col=3)
# assign the year to each measurment
temp2.30=yearassigner(input=temp.30)
# split the data set into a year-based list
temp3.30=split(temp2.30,f=temp2.30$Year)
# find the time [in days] between measurments
datedif.30=datedifference(temp3.30)

# attach the data-difference vector to the list
data.for.model.30=vector("list", length=0)
names.30=names(temp3.30)

for (ii in 1:length(temp3.30)){
  data.for.model.30[[names.30[ii]]]=as.data.frame(cbind(temp3.30[[ii]],datedif.30[[2]][[ii]]))
  names(data.for.model.30[[ii]])[names(data.for.model.30[[ii]]) == 'V1'] = 'Date_seq'
}

# remove empty elements from list
data.for.model.30[sapply(data.for.model.30, is.null)] =NULL

## create a dataframe based on the list for the model
# load the first element of the list
data.for.model.30.df=as.data.frame(data.for.model.30[[1]])
temp.2=data.for.model.30[[1]]
# load all other elements in a loop
for (ii in 2:length(data.for.model.30)){
  temp=as.data.frame(data.for.model.30[[ii]])
  temp.2=rbind(temp.2,temp)
}
data.for.model.30.df=temp.2

lm1.30.NH4=lm(temp3.30$'2010'$NH4~unlist(datedif.30[[2]]$'2010'))
lm2.30.NH4=lm(temp3.30$'2011'$NH4~unlist(datedif.30[[2]]$'2011'))
lm3.30.NH4=lm(temp3.30$'2012'$NH4~unlist(datedif.30[[2]]$'2012'))
lm4.30.NH4=lm(temp3.30$'2013'$NH4~unlist(datedif.30[[2]]$'2013'))

eq.1=fitequation(lm1.30.NH4)
eq.2=fitequation(lm2.30.NH4)
eq.3=fitequation(lm3.30.NH4)
eq.4=fitequation(lm4.30.NH4)

d=ggplot(data=data.for.model.30.df, aes(x=Date_seq, y=NH4, colour=Year))+geom_point()
d=d+labs(title=paste("NH4 build-up depth:", x.depth[2],"[m]", "April 30 to December 1") ,x = "Days from measurment", y = "NH4[quant]")
d=d+geom_smooth(method='lm')
d=d+geom_text(x = 50, y = 6.5E+07, label = eq.1, parse = TRUE, colour="red")
d=d+geom_text(x = 50, y = 6.0E+07, label = eq.2, parse = TRUE, colour="dark green")
d=d+geom_text(x = 50, y = 5.5E+07, label = eq.3, parse = TRUE, colour="blue")
d=d+geom_text(x = 50, y = 5.0E+07, label = eq.4, parse = TRUE, colour="purple")
d

```

simulate NH4 consumption between January $10^{th}$ and March $15^{th}$ in 10m depth in order to estimate reaction rate

```{r NH4 consumption modelling, echo=FALSE, warning=FALSE, message=FALSE, out.width = '600px', out.height = '300px'}
# segment the data to model by dates
# the dates will be segmented into a list containing the relevant dates for every year
temp.10b=datesegmenter( min.date=as.Date("2010-01-10"),max.date=as.Date("2010-03-15"), input=as.data.frame(depth.for.model[[1]]), first.data.col=3)
# assign the year to each measurment
temp2.10b=yearassigner(input=temp.10b)
# split the data set into a year-based list
temp3.10b=split(temp2.10b,f=temp2.10b$Year)
# find the time [in days] between measurments
datedif.10b=datedifference(temp3.10b)

# attach the data-difference vector to the list
data.for.model.10b=vector("list", length=0)
names.10b=names(temp3.10b)

for (ii in 1:length(temp3.10b)){
  data.for.model.10b[[names.10b[ii]]]=as.data.frame(cbind(temp3.10b[[ii]],datedif.10b[[2]][[ii]]))
  names(data.for.model.10b[[ii]])[names(data.for.model.10b[[ii]]) == 'V1'] = 'Date_seq'
}

# remove empty elements from list
data.for.model.10b[sapply(data.for.model.10b, is.null)] =NULL

## create a dataframe based on the list for the model
# load the first element of the list
data.for.model.10b.df=as.data.frame(data.for.model.10b[[1]])
temp.2=data.for.model.10b[[1]]
# load all other elements in a loop
for (ii in 2:length(data.for.model.10b)){
  temp=as.data.frame(data.for.model.10b[[ii]])
  temp.2=rbind(temp.2,temp)
}
data.for.model.10b.df=temp.2

lm2.10b.NH4=lm(temp3.10b$'2011'$NH4~unlist(datedif.10b[[2]]$'2011'))
lm3.10b.NH4=lm(temp3.10b$'2012'$NH4~unlist(datedif.10b[[2]]$'2012'))
lm4.10b.NH4=lm(temp3.10b$'2013'$NH4~unlist(datedif.10b[[2]]$'2013'))

eq.2=fitequation(lm2.10b.NH4)
eq.3=fitequation(lm3.10b.NH4)
eq.4=fitequation(lm4.10b.NH4)

d=ggplot(data=data.for.model.10b.df, aes(x=Date_seq, y=NH4, colour=Year))+geom_point()
d=d+labs(title=paste("NH4 consumption depth:", x.depth[1],"[m]", "January 10 to March 15") ,x = "Days from measurment", y = "NH4[quant]")
d=d+geom_smooth(method='lm')
d=d+geom_text(x = 42, y = 5.0E+07, label = eq.2, parse = TRUE, colour="red")
d=d+geom_text(x = 42, y = 4.5E+07, label = eq.3, parse = TRUE, colour="dark green")
d=d+geom_text(x = 42, y = 4.0E+07, label = eq.4, parse = TRUE, colour="blue")
d

```


simulate nitrate consumption between April $10^{th}$ and July $1^{st}$ in 10m depth in order to estimate reaction rate

```{r nitrate consumption modelling, echo=FALSE, warning=FALSE, message=FALSE, out.width = '600px', out.height = '300px'}
# segment the data to model by dates
# the dates will be segmented into a list containing the relevant dates for every year
temp.10c=datesegmenter( min.date=as.Date("2010-04-10"),max.date=as.Date("2010-07-01"), input=as.data.frame(depth.for.model[[1]]), first.data.col=3)
# assign the year to each measurment
temp2.10c=yearassigner(input=temp.10c)
# split the data set into a year-based list
temp3.10c=split(temp2.10c,f=temp2.10c$Year)
# find the time [in days] between measurments
datedif.10c=datedifference(temp3.10c)

# attach the data-difference vector to the list
data.for.model.10c=vector("list", length=0)
names.10c=names(temp3.10c)

for (ii in 1:length(temp3.10c)){
  data.for.model.10c[[names.10c[ii]]]=as.data.frame(cbind(temp3.10c[[ii]],datedif.10c[[2]][[ii]]))
  names(data.for.model.10c[[ii]])[names(data.for.model.10c[[ii]]) == 'V1'] = 'Date_seq'
}

# remove empty elements from list
data.for.model.10c[sapply(data.for.model.10c, is.null)] =NULL

## create a dataframe based on the list for the model
# load the first element of the list
data.for.model.10c.df=as.data.frame(data.for.model.10c[[1]])
temp.2=data.for.model.10c[[1]]
# load all other elements in a loop
for (ii in 2:length(data.for.model.10c)){
  temp=as.data.frame(data.for.model.10c[[ii]])
  temp.2=rbind(temp.2,temp)
}
data.for.model.10c.df=temp.2

lm1.10c.nitrate=lm(data.for.model.10c$'2010'$Nitrate~unlist(datedif.10c[[2]]$'2010'))
lm2.10c.nitrate=lm(data.for.model.10c$'2011'$Nitrate~unlist(datedif.10c[[2]]$'2011'))
lm3.10c.nitrate=lm(data.for.model.10c$'2012'$Nitrate~unlist(datedif.10c[[2]]$'2012'))
lm4.10c.nitrate=lm(data.for.model.10c$'2013'$Nitrate~unlist(datedif.10c[[2]]$'2013'))

eq.1=fitequation(lm1.10c.nitrate)
eq.2=fitequation(lm2.10c.nitrate)
eq.3=fitequation(lm3.10c.nitrate)
eq.4=fitequation(lm4.10c.nitrate)

d=ggplot(data=data.for.model.10c.df, aes(x=Date_seq, y=Nitrate, colour=Year))+geom_point()
d=d+labs(title=paste("Nitrate consumption depth:", x.depth[1],"[m]", "April 15 to July 1") ,x = "Days from measurment", y = "nitrate[quant]")
d=d+geom_smooth(method='lm')
d=d+geom_text(x = 50, y = 5.5E+07, label = eq.1, parse = TRUE, colour="red")
d=d+geom_text(x = 50, y = 5.1E+07, label = eq.2, parse = TRUE, colour="dark green")
d=d+geom_text(x = 50, y = 4.7E+07, label = eq.3, parse = TRUE, colour="blue")
d=d+geom_text(x = 50, y = 4.3E+07, label = eq.4, parse = TRUE, colour="purple")
d

```

### Coeffiecients assement for all depths

After consideration of the dominant processes that control nitrate and ammonium content in the lake, the following section provides an assesment of the processes and their fit to a linear model in each depth. The $R^2$ value can be used to asses the best fit of the model for each depth. It can be observed that nitrate buildup fits a linear model in most depths, although some intraannual changes illustrate the complexity of the system and its divergence from linearity. The coefficients of the model also show a wide range, and illustrate that the best $R^2$ values were found for the year 2012 (triangles) and values of ca. $a=5*10^6$ and $b=4*10^5$ that describe nitrate build up between Novemebr $1^{st}$ and April $31^{st}$ using the following equation: $$NO_3=5*10^6*t+4*10^5$$, where t is provided in days.

```{r Nitrate buildup modelling all depths, echo=FALSE, warning=FALSE, message=FALSE, out.width = '600px', out.height = '300px'}

x.depth=seq(from=1, to=40, by=1)
data.for.model=vector(mode = "list", length=0)

for (ii in 1:length(x.depth)){
  depth.indices=which(match(data1.split.interp.quant.df$Depth,x.depth[ii])==1)
  data.for.model[[x.depth[ii]]]=data1.split.interp.quant.df[depth.indices,]
}
# remove empty elements from list
data.for.model[sapply(data.for.model, is.null)] =NULL

#define min and max date for modelling
min.date=as.Date("2010-01-01")
max.date=as.Date("2010-03-30")

# initialize empty lists for model parameters collection
lm.Nitrate=vector("list", length=0)
model.param=vector("list", length=0)
Nitrate.model=vector("list", length=0)

for (ii in 1:length(x.depth)){
  temp=datesegmenter(min.date=min.date, max.date=max.date, input=as.data.frame(data.for.model[[x.depth[ii]]]), first.data.col=3)
  
  # assign the year to each measurment
  temp2=yearassigner(input=temp)
  
  # split the data set into a "season-based" list
    temp3=split(temp2,f=temp2$Year)
 # temp3=datesplitter(temp2,min.date=min.date,max.date=max.date)
  
  # cahnge the year value by element name for following plotting with ggplot
  #temp3=yearbyelement(input=temp3)
  
  # find the time [in days] between measurments
  datedif=datedifference(temp3)
  
  # attach the data-difference vector to the list
  data.for.model.loop=vector("list", length=0)
  names=names(temp3)
  
  for (jj in 1:length(temp3)){
    data.for.model.loop[[names[jj]]]=as.data.frame(cbind(temp3[[jj]],datedif[[2]][[jj]]))
    names(data.for.model.loop[[jj]])[names(data.for.model.loop[[jj]]) == 'V1'] = 'Date_seq'
  }
  
  # remove empty elements from list
  data.for.model.loop[sapply(data.for.model.loop, is.null)] =NULL
  
  temp.names=names(temp3)
  for (jj in 1:length(temp.names)){
    lm.Nitrate[[temp.names[jj]]]=lm(temp3[[jj]]$Nitrate~unlist(datedif[[2]][[jj]]))
    
    a = as.double(coef(lm.Nitrate[[jj]])[2])
    b = as.double(coef(lm.Nitrate[[jj]])[1])
    r2 = as.double(summary(lm.Nitrate[[jj]])$r.squared)
    
    model.param[[temp.names[jj]]]=data.frame(ii,a,b,r2)
    rownames(model.param[[temp.names[jj]]]) = ii
    colnames(model.param[[temp.names[jj]]]) = c("Depth", "a", "b","r2")
    model.param=yearbyelement(model.param)

  }
      model.param=yearbyelement(model.param)

  Nitrate.model[[ii]]=model.param
}


temp.df=data.frame(matrix(data=NA, ncol=5, nrow=1))
colnames(temp.df) = colnames((model.param[[temp.names[1]]]))
Nitrate.model.df=data.frame(matrix(data=NA, ncol=5, nrow=40*3))
colnames(Nitrate.model.df) = colnames((model.param[[temp.names[1]]]))
ll=seq(from=1, to=nrow(Nitrate.model.df), by=length(Nitrate.model[[1]]))
       
       for (ii in 1:length(Nitrate.model)){
         for (jj in 1:length(Nitrate.model[[ii]])){
           temp.df=Nitrate.model[[ii]][[jj]]
           Nitrate.model.df[ll[ii]+jj-1,1:5]=temp.df
         }
       }

Nitrate.model.df$Year=as.double(Nitrate.model.df$Year)

summary(Nitrate.model.df[,1:4])
```

```{r Nitrate parameter presentation, echo=FALSE, warning=FALSE, message=FALSE, out.width = '600px', out.height = '300px'}
R2=expression(R^{2})

d=ggplot(Nitrate.model.df, aes(x=factor(as.integer(Depth)), y=r2, colour=as.factor(Year), shape=as.factor(Year)))+geom_point()
d=d+labs(title=paste("Nitrate build-up Linear Modeling: Janaury 1 to March 30") ,x = "Depth [m]", y = "r2")
d=d+scale_shape_discrete(name="Year")
d=d+scale_x_discrete("Depth", breaks=seq(from=0, to=40, by=5))
d=d+scale_y_continuous(R2, breaks=seq(0, to=1, by=0.05))
d=d+scale_color_discrete(name="Year")
d


d=ggplot(Nitrate.model.df, aes(x=as.double(b), y=as.double(a), colour=r2, shape=as.factor(Year)))+geom_point()
d=d+labs(title=paste("Nitrate build-up Linear Modeling: Janaury 1 to March 30") ,x = "b", y = "a")
d=d+scale_colour_gradient2(name=R2, low = "blue", mid = "green" , high = "red", midpoint=0.8)
d=d+scale_shape_discrete(name="Year")
d

d=ggplot(Nitrate.model.df, aes(x=Depth, y=as.double(a), colour=r2, shape=as.factor(Year)))+geom_point()
d=d+labs(title=paste("Nitrate build-up Linear Modeling: Janaury 1 to March 30") ,x = "Depth [m]", y = "a")
d=d+scale_colour_gradient2(name=R2, low = "blue", mid = "green" , high = "red", midpoint=0.8)
d=d+scale_shape_discrete(name="Year")
d

d=d+xlim(15, 40)
d

d=ggplot(Nitrate.model.df, aes(x=as.factor(Year), y=as.double(a), colour=as.factor(Year)))+geom_boxplot()
d=d+labs(title=paste("a parameter for Nitrate build-up: Janaury 1 to March 30") ,x = "Year", y = "a")
d=d+scale_colour_discrete(name="Year")
d

d=ggplot(Nitrate.model.df, aes(x=Depth, y=as.double(b), colour=r2, shape=as.factor(Year)))+geom_point()
d=d+labs(title=paste("Nitrate build-up Linear Modeling: Janaury 1 to March 30") ,x = "Depth [m]", y = "b")
d=d+scale_colour_gradient2(name=R2, low = "blue", mid = "green" , high = "red", midpoint=0.8)
d=d+scale_shape_discrete(name="Year")
d

d=ggplot(Nitrate.model.df, aes(x=as.factor(Year), y=as.double(b), colour=as.factor(Year)))+geom_boxplot()
d=d+labs(title=paste("b parameter for Nitrate build-up: Janaury 1 to March 30") ,x = "Year", y = "b")
d=d+scale_colour_discrete(name="Year")
d

d=d+scale_y_continuous(limits=c(0,0.5E7))
d

```

It can be observed that ammonium buildup does fit the linear model in most depths as nicely as nitrate. Intraannual changes are significatn, and once more illustrate the complexity of the system and its divergence from linearity. The coefficients of the model  show a slightly smaller range, and illustrate that the best $R^2$ values of ca. $a=5*10^6$ and $b=5*10^5$ that describe ammonium build up between April $30^{th}$ and December $1^{st}$ using the following equation: $$NH_4=5*10^6t+5*10^5$$, where t is provided in days. Unsurprisingly, the model has the best fit for depths of 20 to 35m, where oxygenation is solely depends on annual stratification and monomictic mixing.

```{r NH4 build-up modelling all depths, echo=FALSE, warning=FALSE, message=FALSE, out.width = '600px', out.height = '300px'}

x.depth=seq(from=1, to=40, by=1)
data.for.model=vector(mode = "list", length=0)

for (ii in 1:length(x.depth)){
  depth.indices=which(match(data1.split.interp.quant.df$Depth,x.depth[ii])==1)
  data.for.model[[x.depth[ii]]]=data1.split.interp.quant.df[depth.indices,]
}
# remove empty elements from list
data.for.model[sapply(data.for.model, is.null)] =NULL

#define min and max date for modelling
min.date=as.Date("2010-04-30")
max.date=as.Date("2010-12-01")

# initialize empty lists for model parameters collection
lm.NH4=vector("list", length=0)
model.param=vector("list", length=0)
NH4.model=vector("list", length=0)

for (ii in 1:length(x.depth)){
  temp=datesegmenter(min.date=min.date, max.date=max.date, input=as.data.frame(data.for.model[[x.depth[ii]]]), first.data.col=3)
  
  # assign the year to each measurment
  temp2=yearassigner(input=temp)
  
  # split the data set into a "season-based" list
  #temp3=datesplitter(temp2,min.date=min.date,max.date=max.date)
  temp3=split(temp2,f=temp2$Year)
  
  # cahnge the year value by element name for following plotting with ggplot
 # temp3=yearbyelement(input=temp3)
  
  # find the time [in days] between measurments
  datedif=datedifference(temp3)
  
  # attach the data-difference vector to the list
  data.for.model.loop=vector("list", length=0)
  names=names(temp3)
  
  for (jj in 1:length(temp3)){
    data.for.model.loop[[names[jj]]]=as.data.frame(cbind(temp3[[jj]],datedif[[2]][[jj]]))
    names(data.for.model.loop[[jj]])[names(data.for.model.loop[[jj]]) == 'V1'] = 'Date_seq'
  }
  
  # remove empty elements from list
  data.for.model.loop[sapply(data.for.model.loop, is.null)] =NULL
  
  temp.names=names(temp3)
  for (jj in 1:length(temp.names)){
    lm.NH4[[temp.names[jj]]]=lm(temp3[[jj]]$NH4~unlist(datedif[[2]][[jj]]))
    
    a = as.double(coef(lm.NH4[[jj]])[2])
    b = as.double(coef(lm.NH4[[jj]])[1])
    r2 = as.double(summary(lm.NH4[[jj]])$r.squared)
    
    model.param[[temp.names[jj]]]=data.frame(ii,a,b,r2)
    rownames(model.param[[temp.names[jj]]]) = ii
    colnames(model.param[[temp.names[jj]]]) = c("Depth", "a", "b","r2")
    model.param=yearbyelement(model.param)
    
  }
  model.param=yearbyelement(model.param)
  
  NH4.model[[ii]]=model.param
}


temp.df=data.frame(matrix(data=NA, ncol=5, nrow=1))
colnames(temp.df) = colnames((model.param[[temp.names[1]]]))
NH4.model.df=data.frame(matrix(data=NA, ncol=5, nrow=40*4))
colnames(NH4.model.df) = colnames((model.param[[temp.names[1]]]))
ll=seq(from=1, to=nrow(NH4.model.df), by=length(NH4.model[[1]]))

for (ii in 1:length(NH4.model)){
  for (jj in 1:length(NH4.model[[ii]])){
    temp.df=NH4.model[[ii]][[jj]]
    NH4.model.df[ll[ii]+jj-1,1:5]=temp.df
  }
}

NH4.model.df$Year=as.double(NH4.model.df$Year)
summary(NH4.model.df[,1:4])
```

```{r NH4 parameter presentation, echo=FALSE, warning=FALSE, message=FALSE, out.width = '600px', out.height = '300px'}
R2=expression(R^{2})
d=ggplot(NH4.model.df, aes(x=factor(as.integer(Depth)), y=r2, colour=as.factor(Year), shape=as.factor(Year)))+geom_point()
d=d+labs(title=paste("NH4 build-up Linear Modeling: April 30 to December 1") ,x = "Depth [m]", y = "r2")
d=d+scale_x_discrete("Depth", breaks=seq(from=0, to=40, by=5))
d=d+scale_y_continuous(R2, breaks=seq(0, to=1, by=0.1))
d=d+scale_color_discrete(name="Year")
d=d+scale_shape_discrete(name="Year")
d


d=ggplot(NH4.model.df, aes(x=as.double(b), y=as.double(a), colour=r2, shape=as.factor(Year)))+geom_point()
d=d+labs(title=paste("NH4 build-up Linear Modeling: April 30 to December 1") ,x = "b", y = "a")
d=d+scale_colour_gradient2(name=R2, low = "blue", mid = "green" , high = "red", midpoint=0.5)
d=d+scale_shape_discrete(name="Year")
d

d=ggplot(NH4.model.df, aes(x=Depth, y=as.double(a), colour=r2, shape=as.factor(Year)))+geom_point()
d=d+labs(title=paste("NH4 build-up Linear Modeling: April 30 to December 1") ,x = "Depth [m]", y = "a")
d=d+scale_colour_gradient2(name=R2, low = "blue", mid = "green" , high = "red", midpoint=0.5)
d=d+scale_shape_discrete(name="Year")
d

d=d+xlim(20,40)
d


d=ggplot(NH4.model.df, aes(x=as.factor(Year), y=as.double(a), colour=as.factor(Year)))+geom_boxplot()
d=d+labs(title=paste("a parameter for NH4 build-up: April 30 to December 1") ,x = "Year", y = "a")
d=d+scale_colour_discrete(name="Year")
d


d=ggplot(NH4.model.df, aes(x=Depth, y=as.double(b), colour=r2, shape=as.factor(Year)))+geom_point()
d=d+labs(title=paste("NH4 build-up Linear Modeling: April 30 to December 1") ,x = "Depth [m]", y = "b")
d=d+scale_colour_gradient2(name=R2, low = "blue", mid = "green" , high = "red", midpoint=0.5)
d=d+scale_shape_discrete(name="Year")
d

d=d+xlim(20,40)
d

d=ggplot(NH4.model.df, aes(x=as.factor(Year), y=as.double(b), colour=as.factor(Year)))+geom_boxplot()
d=d+labs(title=paste("b parameter for NH4 build-up: April 30 to December 1") ,x = "Year", y = "b")
d=d+scale_colour_discrete(name="Year")
d

d=d+scale_y_continuous(limits=c(0,0.5E7))
d

```

Ammonium consumption after mixing between January $10^{th}$ to March $15^{th}$

```{r NH4 consumption all depths, echo=FALSE, warning=FALSE, message=FALSE, out.width = '600px', out.height = '300px'}

x.depth=seq(from=1, to=40, by=1)
data.for.model=vector(mode = "list", length=0)

for (ii in 1:length(x.depth)){
  depth.indices=which(match(data1.split.interp.quant.df$Depth,x.depth[ii])==1)
  data.for.model[[x.depth[ii]]]=data1.split.interp.quant.df[depth.indices,]
}
# remove empty elements from list
data.for.model[sapply(data.for.model, is.null)] =NULL

#define min and max date for modelling
min.date=as.Date("2010-01-10")
max.date=as.Date("2010-03-15")

# initialize empty lists for model parameters collection
lm.NH4=vector("list", length=0)
model.param=vector("list", length=0)
NH4.model=vector("list", length=0)

for (ii in 1:length(x.depth)){
  temp=datesegmenter(min.date=min.date, max.date=max.date, input=as.data.frame(data.for.model[[x.depth[ii]]]), first.data.col=3)
  
  # assign the year to each measurment
  temp2=yearassigner(input=temp)
  
  # split the data set into a "season-based" list
  #temp3=datesplitter(temp2,min.date=min.date,max.date=max.date)
  temp3=split(temp2,f=temp2$Year)
  
  # cahnge the year value by element name for following plotting with ggplot
 # temp3=yearbyelement(input=temp3)
  
  # find the time [in days] between measurments
  datedif=datedifference(temp3)
  
  # attach the data-difference vector to the list
  data.for.model.loop=vector("list", length=0)
  names=names(temp3)
  
  for (jj in 1:length(temp3)){
    data.for.model.loop[[names[jj]]]=as.data.frame(cbind(temp3[[jj]],datedif[[2]][[jj]]))
    names(data.for.model.loop[[jj]])[names(data.for.model.loop[[jj]]) == 'V1'] = 'Date_seq'
  }
  
  # remove empty elements from list
  data.for.model.loop[sapply(data.for.model.loop, is.null)] =NULL
  
  temp.names=names(temp3)
  for (jj in 1:length(temp.names)){
    lm.NH4[[temp.names[jj]]]=lm(temp3[[jj]]$NH4~unlist(datedif[[2]][[jj]]))

    a = as.double(coef(lm.NH4[[jj]])[2])
    b = as.double(coef(lm.NH4[[jj]])[1])
    r2 = as.double(summary(lm.NH4[[jj]])$r.squared)
    
    model.param[[temp.names[jj]]]=data.frame(ii,a,b,r2)
    rownames(model.param[[temp.names[jj]]]) = ii
    colnames(model.param[[temp.names[jj]]]) = c("Depth", "a", "b","r2")
    model.param=yearbyelement(model.param)
    
  }
  model.param=yearbyelement(model.param)
  
  NH4.model[[ii]]=model.param
}

temp.df=data.frame(matrix(data=NA, ncol=5, nrow=1))
colnames(temp.df) = colnames((model.param[[temp.names[1]]]))
NH4.model.df=data.frame(matrix(data=NA, ncol=5, nrow=40*3))
colnames(NH4.model.df) = colnames((model.param[[temp.names[1]]]))
ll=seq(from=1, to=nrow(NH4.model.df), by=length(NH4.model[[1]]))

for (ii in 1:length(NH4.model)){
  for (jj in 1:length(NH4.model[[ii]])){
    temp.df=NH4.model[[ii]][[jj]]
    NH4.model.df[ll[ii]+jj-1,1:5]=temp.df
  }
}

NH4.model.df$Year=as.double(NH4.model.df$Year)
summary(NH4.model.df[,1:4])
```

```{r NH4 consumption parameter presentation, echo=FALSE, warning=FALSE, message=FALSE, out.width = '600px', out.height = '300px'}
R2=expression(R^{2})

d=ggplot(NH4.model.df, aes(x=factor(as.integer(Depth)), y=r2, colour=as.factor(Year), shape=as.factor(Year)))+geom_point()
d=d+labs(title=paste("NH4 consumption Linear Modeling: January 10 to March 15") ,x = "Depth [m]", y = "r2")
d=d+scale_x_discrete("Depth", breaks=seq(from=0, to=40, by=5))
d=d+scale_y_continuous(R2, breaks=seq(0, to=1, by=0.1))
d=d+scale_shape_discrete(name="Year")
d=d+scale_color_discrete(name="Year")
d


d=ggplot(NH4.model.df, aes(x=as.double(b), y=as.double(a), colour=r2, shape=as.factor(Year)))+geom_point()
d=d+labs(title=paste("NH4 consumption Linear Modeling: January 10 to March 15") ,x = "b", y = "a")
d=d+scale_colour_gradient2(name=R2, low = "blue", mid = "green" , high = "red", midpoint=0.5)
d=d+scale_shape_discrete(name="Year")
d


d=ggplot(NH4.model.df, aes(x=Depth, y=as.double(a), colour=r2, shape=as.factor(Year)))+geom_point()
d=d+labs(title=paste("NH4 consumption Linear Modeling: January 10 to March 15") ,x = "Depth [m]", y = "a")
d=d+scale_colour_gradient2(name=R2, low = "blue", mid = "green" , high = "red", midpoint=0.5)
d=d+scale_shape_discrete(name="Year")
#d=d+geom_smooth(method='lm', colour=c("red", "dark green", "blue"))
d

d=ggplot(NH4.model.df, aes(x=as.factor(Year), y=as.double(a), colour=as.factor(Year)))+geom_boxplot()
d=d+labs(title=paste("a NH4 consumption: January 10 to March 15") ,x = "Year", y = "a")
d=d+scale_colour_discrete(name="Year")
d

d=ggplot(NH4.model.df, aes(x=Depth, y=as.double(b), colour=r2, shape=as.factor(Year)))+geom_point()
d=d+labs(title=paste("NH4 consumption Linear Modeling: January 10 to March 15") ,x = "Depth [m]", y = "b")
d=d+scale_colour_gradient2(name=R2, low = "blue", mid = "green" , high = "red", midpoint=0.5)
d=d+scale_shape_discrete(name="Year")
d

d=ggplot(NH4.model.df, aes(x=as.factor(Year), y=as.double(b), colour=as.factor(Year)))+geom_boxplot()
d=d+labs(title=paste("b NH4 consumption : January 10 to March 15") ,x = "Year", y = "b")
d=d+scale_colour_discrete(name="Year")
d


```

Nitrate consumption after mixing between January $10^{th}$ to March $15^{th}$

```{r NH4 consumption all depths, echo=FALSE, warning=FALSE, message=FALSE, out.width = '600px', out.height = '300px'}

x.depth=seq(from=1, to=40, by=1)
data.for.model=vector(mode = "list", length=0)

for (ii in 1:length(x.depth)){
  depth.indices=which(match(data1.split.interp.quant.df$Depth,x.depth[ii])==1)
  data.for.model[[x.depth[ii]]]=data1.split.interp.quant.df[depth.indices,]
}
# remove empty elements from list
data.for.model[sapply(data.for.model, is.null)] =NULL

#define min and max date for modelling
min.date=as.Date("2010-04-15")
max.date=as.Date("2010-07-01")

# initialize empty lists for model parameters collection
lm.Nitrate.b=vector("list", length=0)
model.param=vector("list", length=0)
Nitrate.b.model=vector("list", length=0)

for (ii in 1:length(x.depth)){
  temp=datesegmenter(min.date=min.date, max.date=max.date, input=as.data.frame(data.for.model[[x.depth[ii]]]), first.data.col=3)
  
  # assign the year to each measurment
  temp2=yearassigner(input=temp)
  
  # split the data set into a "season-based" list
  #temp3=datesplitter(temp2,min.date=min.date,max.date=max.date)
  temp3=split(temp2,f=temp2$Year)
  
  # cahnge the year value by element name for following plotting with ggplot
 # temp3=yearbyelement(input=temp3)
  
  # find the time [in days] between measurments
  datedif=datedifference(temp3)
  
  # attach the data-difference vector to the list
  data.for.model.loop=vector("list", length=0)
  names=names(temp3)
  
  for (jj in 1:length(temp3)){
    data.for.model.loop[[names[jj]]]=as.data.frame(cbind(temp3[[jj]],datedif[[2]][[jj]]))
    names(data.for.model.loop[[jj]])[names(data.for.model.loop[[jj]]) == 'V1'] = 'Date_seq'
  }
  
  # remove empty elements from list
  data.for.model.loop[sapply(data.for.model.loop, is.null)] =NULL
  
  temp.names=names(temp3)
  for (jj in 1:length(temp.names)){
    lm.Nitrate.b[[temp.names[jj]]]=lm(temp3[[jj]]$Nitrate~unlist(datedif[[2]][[jj]]))

    a = as.double(coef(lm.Nitrate.b[[jj]])[2])
    b = as.double(coef(lm.Nitrate.b[[jj]])[1])
    r2 = as.double(summary(lm.Nitrate.b[[jj]])$r.squared)
    
    model.param[[temp.names[jj]]]=data.frame(ii,a,b,r2)
    rownames(model.param[[temp.names[jj]]]) = ii
    colnames(model.param[[temp.names[jj]]]) = c("Depth", "a", "b","r2")
    model.param=yearbyelement(model.param)
    
  }
  model.param=yearbyelement(model.param)
  
  Nitrate.b.model[[ii]]=model.param
}

temp.df=data.frame(matrix(data=NA, ncol=5, nrow=1))
colnames(temp.df) = colnames((model.param[[temp.names[1]]]))
Nitrate.b.model.df=data.frame(matrix(data=NA, ncol=5, nrow=40*4))
colnames(Nitrate.b.model.df) = colnames((model.param[[temp.names[1]]]))
ll=seq(from=1, to=nrow(Nitrate.b.model.df), by=length(Nitrate.b.model[[1]]))

for (ii in 1:length(Nitrate.b.model)){
  for (jj in 1:length(Nitrate.b.model[[ii]])){
    temp.df=Nitrate.b.model[[ii]][[jj]]
    Nitrate.b.model.df[ll[ii]+jj-1,1:5]=temp.df
  }
}

Nitrate.b.model.df$Year=as.double(Nitrate.b.model.df$Year)
summary(Nitrate.b.model.df[,1:4])
```

```{r Nitrate consumption parameter presentation, echo=FALSE, warning=FALSE, message=FALSE, out.width = '600px', out.height = '300px'}
R2=expression(R^{2})

d=ggplot(Nitrate.b.model.df, aes(x=factor(as.integer(Depth)), y=r2, colour=as.factor(Year), shape=as.factor(Year)))+geom_point()
d=d+labs(title=paste("Nitrate consumption Linear Modeling: April 15 to July 1") ,x = "Depth [m]", y = "r2")
d=d+scale_x_discrete("Depth", breaks=seq(from=0, to=40, by=5))
d=d+scale_y_continuous(R2, breaks=seq(0, to=1, by=0.1))
d=d+scale_shape_discrete(name="Year")
d=d+scale_color_discrete(name="Year")
d


d=ggplot(Nitrate.b.model.df, aes(x=as.double(b), y=as.double(a), colour=r2, shape=as.factor(Year)))+geom_point()
d=d+labs(title=paste("Nitrate consumption Linear Modeling: April 15 to July 1") ,x = "b", y = "a")
d=d+scale_colour_gradient2(name=R2, low = "blue", mid = "green" , high = "red", midpoint=0.5)
d=d+scale_shape_discrete(name="Year")
d


d=ggplot(Nitrate.b.model.df, aes(x=Depth, y=as.double(a), colour=r2, shape=as.factor(Year)))+geom_point()
d=d+labs(title=paste("Nitrate consumption Linear Modeling: April 15 to July 1") ,x = "Depth [m]", y = "a")
d=d+scale_colour_gradient2(name=R2, low = "blue", mid = "green" , high = "red", midpoint=0.5)
d=d+scale_shape_discrete(name="Year")
#d=d+geom_smooth(method='lm', colour=c("red", "dark green", "blue"))
d

d=ggplot(Nitrate.b.model.df, aes(x=as.factor(Year), y=as.double(a), colour=as.factor(Year)))+geom_boxplot()
d=d+labs(title=paste("a Nitrate consumption: April 15 to July 1") ,x = "Year", y = "a")
d=d+scale_colour_discrete(name="Year")
d

d=ggplot(Nitrate.b.model.df, aes(x=Depth, y=as.double(b), colour=r2, shape=as.factor(Year)))+geom_point()
d=d+labs(title=paste("Nitrate consumption Linear Modeling: April 15 to July 1") ,x = "Depth [m]", y = "b")
d=d+scale_colour_gradient2(name=R2, low = "blue", mid = "green" , high = "red", midpoint=0.5)
d=d+scale_shape_discrete(name="Year")
d

d=ggplot(Nitrate.b.model.df, aes(x=as.factor(Year), y=as.double(b), colour=as.factor(Year)))+geom_boxplot()
d=d+labs(title=paste("b Nitrate consumption : April 15 to July 1") ,x = "Year", y = "b")
d=d+scale_colour_discrete(name="Year")
d

```
